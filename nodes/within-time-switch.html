<script type="text/x-red" data-template-name="within-time-switch">
    <div class="form-row">
        <label for="node-input-positionConfig"><i class="fa fa-globe"></i> <span data-i18n="within-time-switch.label.position"></span></label>
        <input type="text" id="node-input-positionConfig">
    </div>
    <hr>
    <div class="form-row">
        <label for="node-input-startTime"><i class="fa fa-clock-o"></i> <span data-i18n="within-time-switch.label.startTime"></span></label>
        <input type="text" id="node-input-startTime" style="width: 70%"/>
    </div>
    <div class="form-row time-row">
        <label for="node-input-startOffset"><i class="fa fa-arrows-h"></i> <span data-i18n="within-time-switch.label.startOffset"></span></label>
        <input id="node-input-startOffset"" class="wt-offset-time" data-i18n="[placeholder]within-time-switch.placeholder.startOffset">
        <select style="width:100px" id="node-input-startOffsetMultiplier">
            <option value="1" data-i18n="within-time-switch.label.seconds"></option>
            <option value="60" data-i18n="within-time-switch.label.minutes"></option>
            <option value="3600" data-i18n="within-time-switch.label.hours"></option>
        </select>
    </div>
    <div class="form-row">
        <label for="node-input-endTime"><i class="fa fa-clock-o"></i> <span data-i18n="within-time-switch.label.endTime"></span></label>
        <input type="text" id="node-input-endTime" style="width: 70%"/>
    </div>
    <div class="form-row time-row">
        <label for="node-input-endOffset"><i class="fa fa-arrows-h"></i> <span data-i18n="within-time-switch.label.endOffset"></span></label>
        <input id="node-input-endOffset" class="wt-offset-time" data-i18n="[placeholder]within-time-switch.placeholder.endOffset">
        <select style="width:100px" id="node-input-endOffsetMultiplier">
            <option value="1" data-i18n="within-time-switch.label.seconds"></option>
            <option value="60" data-i18n="within-time-switch.label.minutes"></option>
            <option value="3600" data-i18n="within-time-switch.label.hours"></option>
        </select>
    </div>
    <hr>
    <div class="form-tips">
        <span data-i18n="[html]within-time-switch.tips.addTimes"></span>&nbsp;
    </div>
    <div class="form-row"/>
    <div class="form-row">
        <label ><i class="fa fa-tag"></i> <span data-i18n="within-time-switch.label.propertyStart"></span></label>
        <input type="text" id="node-input-propertyStart" style="width: 70%"/>
    </div>
    <div class="form-row alternate-time-start hidden">
        <label for="node-input-startTimeAlt"><i class="fa fa-clock-o"></i> <span data-i18n="within-time-switch.label.startTimeAlt"></span></label>
        <input type="text" id="node-input-startTimeAlt" style="width: 70%"/>
    </div>
    <div class="form-row alternate-time-start-offset hidden">
        <label for="node-input-startOffsetAlt"><i class="fa fa-arrows-h"></i> <span data-i18n="within-time-switch.label.startOffsetAlt"></span></label>
        <input id="node-input-startOffsetAlt"" class="wt-offset-time" data-i18n="[placeholder]within-time-switch.placeholder.startOffset">
        <select style="width:100px" id="node-input-startOffsetAltMultiplier">
            <option value="1" data-i18n="within-time-switch.label.seconds"></option>
            <option value="60" data-i18n="within-time-switch.label.minutes"></option>
            <option value="3600" data-i18n="within-time-switch.label.hours"></option>
        </select>
    </div>
    <div class="form-row">
        <label ><i class="fa fa-tag"></i> <span data-i18n="within-time-switch.label.propertyEnd"></span></label>
        <input type="text" id="node-input-propertyEnd" style="width: 70%"/>
    </div>
    <div class="form-row alternate-time-end hidden">
        <label for="node-input-endTimeAlt"><i class="fa fa-clock-o"></i> <span data-i18n="within-time-switch.label.endTimeAlt"></span></label>
        <input type="text" id="node-input-endTimeAlt" style="width: 70%"/>
    </div>
    <div class="form-row alternate-time-end-offset hidden">
        <label for="node-input-endOffsetAlt"><i class="fa fa-arrows-h"></i> <span data-i18n="within-time-switch.label.endOffsetAlt"></span></label>
        <input id="node-input-endOffsetAlt" class="wt-offset-time" data-i18n="[placeholder]within-time-switch.placeholder.endOffset">
        <select style="width:100px" id="node-input-endOffsetAltMultiplier">
            <option value="1" data-i18n="within-time-switch.label.seconds"></option>
            <option value="60" data-i18n="within-time-switch.label.minutes"></option>
            <option value="3600" data-i18n="within-time-switch.label.hours"></option>
        </select>
    </div>
    <hr>
    <div class="form-row debug-row">
        <label for="node-input-statusOut"><i class="fa fa-bug"></i> <span data-i18n="within-time-switch.label.statusOut"></span></label>
        <select id="node-input-statusOut"  style="width:70%;" >
            <option value="0" data-i18n="within-time-switch.label.statusOnlyError"></option>
            <option value="1" data-i18n="within-time-switch.label.statusTime"></option>
            <option value="2" data-i18n="within-time-switch.label.statusSend"></option>
            <option value="3" data-i18n="within-time-switch.label.statusTimeOrSend"></option>
            <option value="256" data-i18n="within-time-switch.label.statusNone"></option>
        </select>
    </div>
    <div class="form-row msg-start-out-row">
        <label for="node-input-lastMsgOnStartOut"><i class="fa fa-forward"></i> <span data-i18n="within-time-switch.label.lastMsgOnStartOut"></span></label>
        <input type="checkbox" id="node-input-lastMsgOnStartOut" style="display:inline-block; width:15px; vertical-align:baseline;">
        <span data-i18n="within-time-switch.label.lastMsgOnStartOutTxt"></span>
    </div>
    <div class="form-row msg-end-out-row">
        <label for="node-input-lastMsgOnEndOut"><i class="fa fa-fast-forward"></i> <span data-i18n="within-time-switch.label.lastMsgOnEndOut"></span></label>
        <input type="checkbox" id="node-input-lastMsgOnEndOut" style="display:inline-block; width:15px; vertical-align:baseline;">
        <span data-i18n="within-time-switch.label.lastMsgOnEndOutTxt"></span>
    </div>
    <hr>
    <div class="form-row">
        <label for="node-input-name"><i class="icon-tag"></i> <span data-i18n="within-time-switch.label.name"></span></label>
        <input type="text" id="node-input-name" data-i18n="[placeholder]within-time-switch.placeholder.name">
    </div>
</script>

<script type="text/x-red" data-help-name="within-time-switch">
    <p>A simple node that routes messages depending on the time. If the current time falls within the range specified in the node configuration, the message is routed to output 1. Otherwise the message is routed to output 2.</p>

    <h3>Settings</h3>
        <dl class="message-properties"><dt>Position</dt><dd>defines the current position</dd></dl>
        <dl class="message-properties"><dt>Start time</dt><dd>defines the start time of the time range with with different [configuration possibilities](#times-definitions)</dd></dl>
        <dl class="message-properties"><dt>Start Offset</dt><dd>allows to define a positive or negative offset in *seconds*, *minutes* or *hours* to the given **Start Time**. This will be useful for sun based times.</dd></dl>
        <dl class="message-properties"><dt>End time</dt><dd>defines the end time of the time range with with different [configuration possibilities](#times-definitions)</dd></dl>
        <dl class="message-properties"><dt>End Offset</dt><dd>allows to define a positive or negative offset in *seconds*, *minutes* or *hours* to the given **End Time**. This will be useful for sun based times.</dd></dl>
        <dl class="message-properties"><dt>Property</dt><dd>_optional_ here can be defined a boolean property. If it is true alternate start or and times will be used.</dd></dl>
        <dl class="message-properties"><dt>Alternate start time</dt><dd>_optional_ defines an alternate start time of the time range which will be used if the property is true. This can be used for different times for example of holidays.</dd></dl>
        <dl class="message-properties"><dt>Start time</dt><dd>alternate start time</dd></dl>
        <dl class="message-properties"><dt>End Offset</dt><dd>offset for the alternate start time</dd></dl>
        <dl class="message-properties"><dt>Alternate end time</dt><dd>_optional_ defines an alternate end time of the time range which will be used if the property is true. This can be used for different times for example of holidays.</dd></dl>
        <dl class="message-properties"><dt>End time</dt><dd>alternate end time</dd></dl>
        <dl class="message-properties"><dt>Offset</dt><dd>offset for the alternate end time</dd></dl>
        <dl class="message-properties"><dt>Status</dt><dd>here can be adjusted which status should be displayed under the node.</dd></dl>
        <dl class="message-properties"><dt>time limits or last message</dt><dd>- on deploy/start until a message arrives the same behaviour as `time limits` options, otherwise the `last message` status display.</dd></dl>
        <dl class="message-properties"><dt>resend start</dt><dd>If this checkbox is checked and a message arrived outside of time, this message will be additional send again some milliseconds after next start time point. This option is only for fixed time definitions available.</dd></dl>
        <dl class="message-properties"><dt>resend end</dt><dd>If this checkbox is checked and a message arrived within time, this message will be additional send again some milliseconds after next end time point. This option is only for fixed time definitions available.</dd></dl>

    <h3>Time definitions</h3>
    <p>The time definitions has different configuration possibilities.</p>
    <table>
        <thead>
        <tr>
        <th>Time</th>
        <th>Description</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><code>astronomicalDawn</code></td>
        <td>night ends (morning astronomical twilight starts)</td>
        </tr>
        <tr>
        <td><code>amateurDawn</code></td>
        <td>amateur astronomical dawn (sun at 12° before sunrise)</td>
        </tr>
        <tr>
        <td><code>nauticalDawn</code></td>
        <td>nautical dawn (morning nautical twilight starts)</td>
        </tr>
        <tr>
        <td><code>blueHourDawnStart</code></td>
        <td>blue Hour start (time for special photography photos starts)</td>
        </tr>
        <tr>
        <td><code>civilDawn</code></td>
        <td>dawn (morning nautical twilight ends, morning civil twilight starts)</td>
        </tr>
        <tr>
        <td><code>blueHourDawnEnd</code></td>
        <td>blue Hour end (time for special photography photos end)</td>
        </tr>
        <tr>
        <td><code>sunrise</code></td>
        <td>sunrise (top edge of the sun appears on the horizon)</td>
        </tr>
        <tr>
        <td><code>sunriseEnd</code></td>
        <td>sunrise ends (bottom edge of the sun touches the horizon)</td>
        </tr>
        <tr>
        <td><code>goldenHourEnd</code></td>
        <td>morning golden hour (soft light, best time for photography) ends</td>
        </tr>
        <tr>
        <td><code>solarNoon</code></td>
        <td>solar noon (sun is in the highest position)</td>
        </tr>
        <tr>
        <td><code>goldenHourStart</code></td>
        <td>evening golden hour starts</td>
        </tr>
        <tr>
        <td><code>sunsetStart</code></td>
        <td>sunset starts (bottom edge of the sun touches the horizon)</td>
        </tr>
        <tr>
        <td><code>sunset</code></td>
        <td>sunset (sun disappears below the horizon, evening civil twilight starts)</td>
        </tr>
        <tr>
        <td><code>blueHourDuskStart</code></td>
        <td>blue Hour start (time for special photography photos starts)</td>
        </tr>
        <tr>
        <td><code>civilDusk</code></td>
        <td>dusk (evening nautical twilight starts)</td>
        </tr>
        <tr>
        <td><code>blueHourDuskEnd</code></td>
        <td>blue Hour end (time for special photography photos end)</td>
        </tr>
        <tr>
        <td><code>nauticalDusk</code></td>
        <td>nautical dusk end (evening astronomical twilight starts)</td>
        </tr>
        <tr>
        <td><code>amateurDusk</code></td>
        <td>amateur astronomical dusk (sun at 12° after sunrise)</td>
        </tr>
        <tr>
        <td><code>astronomicalDusk</code></td>
        <td>night starts (dark enough for astronomical observations)</td>
        </tr>
        <tr>
        <td><code>nadir</code></td>
        <td>nadir (darkest moment of the night, sun is in the lowest position)</td>
        </tr>
        </tbody>
        </table>
            <h3>References</h3>
           <ul>
               <li><a href="https://flows.nodered.org/node/node-red-contrib-sun-position">Node-Red</a> - the Node-Red Node overview</li>
               <li><a href="https://github.com/HM-RedMatic/node-red-contrib-sun-position">GitHub</a> - the nodes github repository</li>
               <li><a href="https://flows.nodered.org/node/node-red-contrib-sun-position">NPM</a> - the nodes npm node description</li>
           </ul>
           With friendly support by <b>agag</b>.
</script>

<script type="text/javascript">
    function clipValueLength(v, l) {
        if (v.length > l) {
            return v.substring(0, (l - 3)) + "...";
        }
        return v;
    }

    function getValueLabel(t, v, l) {
        l = l || 15;
        if (t === "string" || t === "str") {
            if (v == "") {
                return v;
            }
            return '"' + clipValueLength(v, l) + '"';
        } else if (t === "num" || t === "bool") {
            if (v == "") {
                return v;
            }
            return "" + v;
        } else if (t === 'msg') {
            return t + "." + clipValueLength(v, l);
        } else if (t === 'flow' || t === 'global') {
            var result = RED.utils.parseContextKey(v);
            return t + "." + clipValueLength(result.key, l);
        } else if (t == "pdsCalcData") {
            return "{sun position}";
        } else if (t == "pdmCalcData") {
            return "{moon position}";
        } else if (t == "pdsTime") {
            let res = v.replace('astronomical', 'astro-').replace('nautical', 'naut-').replace('civil', '').replace(
                'amateur', 'amat-').replace('blueHour', 'blHr-').replace('goldenHour', 'goHr-');
            return clipValueLength(res, l);
        } else if (t == "pdmTime") {
            return "moon" + v;
        }
        return clipValueLength(v, l);
    }

    RED.nodes.registerType('within-time-switch', {
        category: 'time',
        color: '#f37a33',
        defaults: {
            name: {
                value: "",
                required: false
            },
            positionConfig: {
                value: "",
                type: "position-config",
                required: true
            },
            startTime: {
                value: "",
                required: true,
                validate: RED.validators.typedInput("startTimeType")
            },
            startTimeType: {
                value: "entered"
            },
            startOffset: {
                value: 0,
                required: true,
                validate: RED.validators.number()
            },
            startOffsetMultiplier: {
                value: 60,
                required: true,
                validate: RED.validators.number()
            },
            endTime: {
                value: "",
                required: true,
                validate: RED.validators.typedInput("endTimeType")
            },
            endTimeType: {
                value: "entered"
            },
            endOffset: {
                value: 0,
                required: true,
                validate: RED.validators.number()
            },
            endOffsetMultiplier: {
                value: 60,
                required: true,
                validate: RED.validators.number()
            },
            propertyStart: {
                value: "",
                required: false,
                validate: RED.validators.typedInput("propertyStartType")
            },
            propertyStartType: {
                value: "none"
            },
            startTimeAlt: {
                value: '',
                required: false,
                validate: function (v) {
                    return RED.validators.typedInput("startTimeAltType")(v) || ($(
                        "#node-input-propertyStart").typedInput(
                        'type') === 'none');
                }
            },
            startTimeAltType: {
                value: "none"
            },
            startOffsetAlt: {
                value: 0,
                required: true,
                validate: function (v) {
                    return RED.validators.number()(v) ||
                        ($("#node-input-propertyStart").typedInput('type') === 'none') ||
                        ($("#node-input-startTimeAlt").typedInput('type') === 'none');
                }
            },
            startOffsetAltMultiplier: {
                value: 60,
                required: true,
                validate: function (v) {
                    return RED.validators.number()(v) ||
                        ($("#node-input-propertyStart").typedInput('type') === 'none') ||
                        ($("#node-input-startTimeAlt").typedInput('type') === 'none');
                }
            },
            propertyEnd: {
                value: "",
                required: false,
                validate: RED.validators.typedInput("propertyEndType")
            },
            propertyEndType: {
                value: "none"
            },
            endTimeAlt: {
                value: '',
                required: false,
                validate: function (v) {
                    return RED.validators.typedInput("endTimeAltType")(v) || ($("#node-input-propertyEnd").typedInput(
                        'type') === 'none');
                }
            },
            endTimeAltType: {
                value: "none"
            },
            endOffsetAlt: {
                value: 0,
                required: true,
                validate: function (v) {
                    return RED.validators.number()(v) ||
                        ($("#node-input-propertyEnd").typedInput('type') === 'none') ||
                        ($("#node-input-endTimeAlt").typedInput('type') === 'none');
                }
            },
            endOffsetAltMultiplier: {
                value: 60,
                required: true,
                validate: function (v) {
                    return RED.validators.number()(v) ||
                        ($("#node-input-propertyEnd").typedInput('type') === 'none') ||
                        ($("#node-input-endTimeAlt").typedInput('type') === 'none');
                }
            },
            statusOut: {
                value: 3,
                required: false
            },
            lastMsgOnStartOut: {
                value: false,
                required: false
            },
            lastMsgOnEndOut: {
                value: false,
                required: false
            }
        },
        icon: 'switch.png',
        inputs: 1,
        outputs: 2,
        outputLabels: ["within time", "out of time"],
        label: function () {
            const getId = (type, value, offset, maxLength) => {
                let suffix = '';
                if (offset && offset > 0) {
                    suffix = '↷';
                } else if (offset && offset < 0) {
                    suffix = '↶';
                }

                if (type === "jsonata") {
                    if (value.length < 15) {
                        return value + suffix;
                    }
                    return this._("within-time-switch.label.jsonata");
                } else if (type === "json") {
                    if (value.length < 15) {
                        return value + suffix;
                    }
                    return this._("within-time-switch.label.json") + suffix;
                } else if (type === "bin") {
                    return this._("within-time-switch.label.binary") + suffix;
                } else if (type === "date") {
                    return this._("within-time-switch.label.timestamp") + suffix;
                }

                let v = getValueLabel(type, value, maxLength);
                if (v == "") {
                    return this._("within-time-switch.label.blank");
                }
                return v + suffix;
            }

            const getConcatId = (type1, value1, offset1, property, type2, value2, offset2) => {
                if (property !== 'none' && property !== '' && value2) {
                    return getId(type1, value1, offset1, 12) + '/' + getId(type2, value2, offset2, 12);
                }
                return getId(type1, value1, undefined, 12);
            }

            if (this.name) {
                return this.name;
            } else if (this.startTime && this.endTime) {
                return getConcatId(this.startTimeType, this.startTime, this.startOffset, this.propertyStartType,
                        this.startTimeAltType, this.startTimeAlt, this.startOffsetAlt) +
                        ((this.lastMsgOnStartOut) ? '⨧ - ' : ' - ')
                    +
                    getConcatId(this.endTimeType, this.endTime, this.endOffset, this.propertyEndType,
                        this.endTimeAltType, this.endTimeAlt, this.endTimeAltOffset) +
                        ((this.lastMsgOnEndOut) ? '⨧' : '');
            }
            return 'within-time';
        },
        labelStyle: function () {
            return this.name ? "node_label_italic" : "";
        },
        paletteLabel: 'within-time',
        align: 'left',
        oneditprepare: function () {

            function checkMsgOnStartOut() {
                let valStart = $("#node-input-startTime").typedInput('type');
                let valStartAlt = $("#node-input-startTimeAlt").typedInput('type');
                let vals = ',entered,pdsTime,pdmTime,flow,global,jsonata,env,';

                if (vals.indexOf(valStart) >=0 && (valStartAlt === 'none' || vals.indexOf(valStartAlt) >=0)) {
                    $(".msg-start-out-row").show();
                } else {
                    $(".msg-start-out-row").hide();
                }
            }

            function checkMsgOnEndOut() {
                let valEnd = $("#node-input-endTime").typedInput('type');
                let valEndAlt = $("#node-input-endTimeAlt").typedInput('type');
                let vals = ',entered,pdsTime,pdmTime,flow,global,jsonata,env,';

                if (vals.indexOf(valEnd) >=0 && (valEndAlt === 'none' || vals.indexOf(valEndAlt) >=0)) {
                    $(".msg-end-out-row").show();
                } else {
                    $(".msg-end-out-row").hide();
                }
            }

            if (this.statusOut == "" || this.statusOut == undefined) {
                this.statusOut = 3;
                $("#node-input-statusOut").val(this.statusOut);
            }

            $(".wt-offset-time").spinner({
                max: 1439,
                min: -1439
            });

            let typeTimeNone = {
                value: "none",
                label: "not used ",
                icon: "icons/node-red-contrib-sun-position/inputTypeNone.png",
                hasValue: false
            };
            let typeTime = {
                value: "entered",
                label: "timestamp ",
                icon: "icons/node-red-contrib-sun-position/inputTypeTime.png",
                hasValue: true,
                validate: /^(0[0-9]|[0-9]|1[0-9]|2[0-3])(?::([0-5][0-9]|[0-9]))?(?::([0-5][0-9]|[0-9]))?\s*(pm?)?$/
            };
            let typeTimeSun = {
                value: "pdsTime",
                label: "sun ",
                icon: "icons/node-red-contrib-sun-position/inputTypeSun.png",
                options: [
                    "astronomicalDawn",
                    "amateurDawn",
                    "nauticalDawn",
                    "blueHourDawnStart",
                    "civilDawn",
                    "blueHourDawnEnd",
                    "sunrise",
                    "sunriseEnd",
                    "goldenHourEnd",
                    "solarNoon",
                    "goldenHourStart",
                    "sunsetStart",
                    "sunset",
                    "blueHourDuskStart",
                    "civilDusk",
                    "blueHourDuskEnd",
                    "amateurDusk",
                    "astronomicalDusk",
                    "nadir"
                ]
            };
            let typeTimeMoon = {
                value: "pdmTime",
                label: "moon ",
                icon: "icons/node-red-contrib-sun-position/inputTypeMoon.png",
                options: ['rise', 'set']
            };

            $("#node-input-propertyStart").typedInput({
                default: this.propertyStartType || 'none',
                types: [typeTimeNone, 'msg', 'flow', 'global', 'jsonata', 'env']
            });
            $("#node-input-propertyEnd").typedInput({
                default: this.propertyEndType || 'none',
                types: [typeTimeNone, 'msg', 'flow', 'global', 'jsonata', 'env']
            });
            $("#node-input-propertyStart").on('change', function (type, value) {
                if ($("#node-input-propertyStart").typedInput('type') === 'none') {
                    $(".alternate-time-start").hide();
                    $(".alternate-time-start-offset").hide();
                } else {
                    $(".alternate-time-start").show();
                }
                $("#node-input-startTimeAlt").change();
            });
            $("#node-input-propertyEnd").on('change', function (type, value) {
                if ($("#node-input-propertyEnd").typedInput('type') === 'none') {
                    $(".alternate-time-end").hide();
                    $(".alternate-time-end-offset").hide();
                } else {
                    $(".alternate-time-end").show();
                }
                $("#node-input-endTimeAlt").change();
            });

            $("#node-input-startTime").typedInput({
                default: this.startTimeType || 'entered',
                types: [typeTime, typeTimeSun, typeTimeMoon, 'msg', 'flow', 'global', 'env']
            });
            $('#node-input-startTime').on('change focus focusin focusout', function (type, value) {
                checkMsgOnStartOut(type, value);
            });
            $("#node-input-endTime").typedInput({
                default: this.endTimeType || 'entered',
                types: [typeTime, typeTimeSun, typeTimeMoon, 'msg', 'flow', 'global', 'env']
            });
            $('#node-input-endTime').on('change focus focusin focusout', function (type, value) {
                checkMsgOnEndOut(type, value);
            });
            $("#node-input-startTimeAlt").typedInput({
                default: this.startTimeAltType || 'none',
                types: [typeTimeNone, typeTime, typeTimeSun, typeTimeMoon, 'msg', 'flow', 'global', 'env']
            });
            $("#node-input-startTimeAlt").on('change focus focusin focusout', function (type, value) {
                if (($("#node-input-startTimeAlt").typedInput('type') === 'none') ||
                    ($("#node-input-propertyStart").typedInput('type') === 'none')) {
                    $(".alternate-time-start-offset").hide();
                } else {
                    $(".alternate-time-start-offset").show();
                }
                checkMsgOnStartOut();
            });
            $("#node-input-endTimeAlt").typedInput({
                default: this.endTimeAltType || 'none',
                types: [typeTimeNone, typeTime, typeTimeSun, typeTimeMoon, 'msg', 'flow', 'global', 'env']
            });
            $("#node-input-endTimeAlt").on('change focus focusin focusout', function (type, value) {
                if (($("#node-input-endTimeAlt").typedInput('type') === 'none') ||
                    ($("#node-input-propertyEnd").typedInput('type') === 'none')) {
                    $(".alternate-time-end-offset").hide();
                } else {
                    $(".alternate-time-end-offset").show();
                }
                checkMsgOnEndOut();
            });
            //$("#node-input-startTimeAlt").change();
            //$("#node-input-endTimeAlt").change();
            $("#node-input-propertyStart").change();
            $("#node-input-propertyEnd").change();
        },
        oneditsave: function () {
            this.propertyStartType = $("#node-input-propertyStart").typedInput('type');
            this.propertyEndType = $("#node-input-propertyEnd").typedInput('type');
            this.startTimeType = $("#node-input-startTime").typedInput('type');
            this.endTimeType = $("#node-input-endTime").typedInput('type');
            this.startTimeAltType = $("#node-input-startTimeAlt").typedInput('type');
            this.endTimeAltType = $("#node-input-endTimeAlt").typedInput('type');
        }
    });
</script>