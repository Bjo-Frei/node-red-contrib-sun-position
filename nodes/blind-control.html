<script type="text/x-red" data-template-name="blind-control">
    <div class="form-row">
        <label for="node-input-positionConfig"><i class="fa fa-globe"></i> <span data-i18n="blind-control.label.position"></span></label>
        <input type="text" id="node-input-positionConfig">
        <input type="hidden" id="node-input-outputs"/>
    </div>
    <hr>
    <!-- window ######################################################################## -->
    <div class="form-row">
        <label for="node-input-windowTop"><i class="fa fa-arrow-up"></i> <span data-i18n="blind-control.label.windowTop"></span></label>
        <input type="number" id="node-input-windowTop" >
    </div>
    <div class="form-row">
        <label for="node-input-windowBottom"><i class="fa fa-arrow-down"></i> <span data-i18n="blind-control.label.windowBottom"></span></label>
        <input type="number" id="node-input-windowBottom" >
    </div>
    <div class="form-row">
        <label for="node-input-windowAngle"><i class="fa fa-arrow-down"></i> <span data-i18n="blind-control.label.windowAngle"></span></label>
        <input type="number" id="node-input-windowAngle" >
    </div>
    <div class="form-row">
        <label for="node-input-windowAngleOffsetStart"><i class="fa fa-arrow-down"></i> <span data-i18n="blind-control.label.windowAngleOffsetStart"></span></label>
        <input type="number" id="node-input-windowAngleOffsetStart" >
    </div>
    <div class="form-row">
        <label for="node-input-windowAngleOffsetEnd"><i class="fa fa-arrow-down"></i> <span data-i18n="blind-control.label.windowAngleOffsetEnd"></span></label>
        <input type="number" id="node-input-windowAngleOffsetEnd" >
    </div>
    <hr>
    <!-- #region blind ######################################################################## -->
    <div class="form-row">
        <label for="node-input-blindIncrement"><i class="fa fa-arrow-up"></i> <span data-i18n="blind-control.label.blindIncrement"></span></label>
        <input type="number" id="node-input-blindIncrement" >
    </div>
    <div class="form-row">
        <label for="node-input-blindOpenPos"><i class="fa fa-arrow-up"></i> <span data-i18n="blind-control.label.blindOpenPos"></span></label>
        <input type="number" id="node-input-blindOpenPos" >
    </div>
    <div class="form-row">
        <label for="node-input-blindClosedPos"><i class="fa fa-arrow-up"></i> <span data-i18n="blind-control.label.blindClosedPos"></span></label>
        <input type="number" id="node-input-blindClosedPos" >
    </div>
    <div class="form-row">
        <label for="node-input-blindPosOverwriteExpire"><i class="fa fa-arrow-up"></i> <span data-i18n="blind-control.label.blindPosOverwriteExpire"></span></label>
        <input type="number" id="node-input-blindPosOverwriteExpire" >
        <select id="node-input-endOffsetMultiplier" class="node-input-multiplier"></select>
    </div>
    <hr>
    <!-- #region time ######################################################################## -->
    <div class="form-row">
        <label for="node-input-blindNightPos"><i class="fa fa-arrow-up"></i> <span data-i18n="blind-control.label.blindNightPos"></span></label>
        <input type="number" id="node-input-blindNightPos" >
    </div>
    <div class="form-row block-noindent">
        <label for="node-input-startTime"><i class="fa fa-clock-o"></i> <span data-i18n="within-time-switch.label.startTime"></span></label>
        <input type="text" id="node-input-startTime" />
        <input type="hidden" id="node-input-startTimeType">
    </div>
    <div class="form-row block-indent1 within-time-switch-row-startOffset">
        <label for="node-input-startOffset"><i class="fa fa-calculator"></i> <span data-i18n="within-time-switch.label.startOffset"></span></label>
        <input id="node-input-startOffset" data-i18n="[placeholder]within-time-switch.placeholder.startOffset"></input>
        <input type="hidden" id="node-input-startOffsetType">
        <select id="node-input-startOffsetMultiplier" class="node-input-multiplier"></select>
    </div>

    <div class="form-row block-noindent">
        <label for="node-input-endTime"><i class="fa fa-clock-o"></i> <span data-i18n="within-time-switch.label.endTime"></span></label>
        <input type="text" id="node-input-endTime" />
        <input type="hidden" id="node-input-endTimeType">
    </div>
    <div class="form-row block-indent1 within-time-switch-row-endOffset">
        <label for="node-input-endOffset"><i class="fa fa-calculator"></i> <span data-i18n="within-time-switch.label.endOffset"></span></label>
        <input id="node-input-endOffset" data-i18n="[placeholder]within-time-switch.placeholder.endOffset"></input>
        <input type="hidden" id="node-input-endOffsetType">
        <select id="node-input-endOffsetMultiplier" class="node-input-multiplier"></select>
    </div>
    <hr>
    <div class="form-tips">
        <span data-i18n="[html]within-time-switch.tips.addTimes"></span>&nbsp;
    </div>
    <div class="form-row"/>
    <div class="form-row alternate-property-start">
        <label for="node-input-propertyStart"><i class="fa fa-sun-o"></i> <span data-i18n="within-time-switch.label.propertyStart"></span></label>
        <input type="text" id="node-input-propertyStart"/>
        <input type="hidden" id="node-input-propertyStartType">
    </div>
    <div class="form-row block-indent1 alternate-time-start hidden">
        <label for="node-input-startTimeAlt"><i class="fa fa-clock-o"></i> <span data-i18n="within-time-switch.label.startTimeAlt"></span></label>
        <input type="text" id="node-input-startTimeAlt"/>
        <input type="hidden" id="node-input-startTimeAltType">
    </div>
    <div class="form-row block-indent1 alternate-time-start-offset hidden">
        <label for="node-input-startTimeAltOffset"><i class="fa fa-calculator"></i> <span data-i18n="within-time-switch.label.startTimeAltOffset"></span></label>
        <input id="node-input-startTimeAltOffset" data-i18n="[placeholder]within-time-switch.placeholder.startTimeAltOffset"></input>
        <input type="hidden" id="node-input-startTimeAltOffsetType">
        <select id="node-input-startTimeAltOffsetMultiplier" class="node-input-multiplier"></select>
    </div>
    <div class="form-row alternate-property-end">
        <label for="node-input-propertyEnd"><i class="fa fa-sun-o"></i> <span data-i18n="within-time-switch.label.propertyEnd"></span></label>
        <input type="text" id="node-input-propertyEnd"/>
        <input type="hidden" id="node-input-propertyEndType">
    </div>
    <div class="form-row block-indent1 alternate-time-end hidden">
        <label for="node-input-endTimeAlt"><i class="fa fa-clock-o"></i> <span data-i18n="within-time-switch.label.endTimeAlt"></span></label>
        <input type="text" id="node-input-endTimeAlt"/>
        <input type="hidden" id="node-input-endTimeAltType">
    </div>
    <div class="form-row block-indent1 alternate-time-end-offset hidden">
        <label for="node-input-endTimeAltOffset"><i class="fa fa-calculator"></i> <span data-i18n="within-time-switch.label.endTimeAltOffset"></span></label>
        <input id="node-input-endTimeAltOffset" data-i18n="[placeholder]within-time-switch.placeholder.endTimeAltOffset"></input>
        <input type="hidden" id="node-input-endTimeAltOffsetType">
        <select id="node-input-endTimeAltOffsetMultiplier" class="node-input-multiplier"></select>
    </div>
    <hr>
    <!-- #region sun ######################################################################## -->
    <div class="form-row block-noindent">
      <label for="node-input-sunControlActive"><i class="fa fa-play-circle"></i> <span data-i18n="time-inject.label.sunControlActive"></span></label>
      <input type="checkbox" id="node-input-sunControlActive" style="display:inline-block; width:15px; vertical-align:baseline;">
      <span data-i18n="time-inject.label.sunControlActiveText"></span>&nbsp;
    </div>
    <div class="form-row block-indent1">
        <label for="node-input-sunFloorLength"><i class="fa fa-arrow-up"></i> <span data-i18n="blind-control.label.sunFloorLength"></span></label>
        <input type="number" id="node-input-sunFloorLength" >
    </div>
    <div class="form-row block-indent1">
        <label for="node-input-sunMinAltitude"><i class="fa fa-arrow-up"></i> <span data-i18n="blind-control.label.sunMinAltitude"></span></label>
        <input type="number" id="node-input-sunMinAltitude" >
    </div>
    <div class="form-row block-noindent">
        <label for="node-input-notVisiblePos"><i class="fa fa-arrow-up"></i> <span data-i18n="blind-control.label.notVisiblePos"></span></label>
        <input type="number" id="node-input-notVisiblePos" >
    </div>
    <hr>
    <!-- #region weather ######################################################################## -->
    <div class="form-row">
        <label for="node-input-tempThreshold"><i class="fa fa-tachometer"></i> <span data-i18n="blindcontroller.label.tempThreshold"></span></label>
        <input type="number" id="node-input-tempThreshold">
    </div>
    <div class="form-row">
        <label for="node-input-tempBlindPos"><i class="fa fa-angle-down"></i> <span data-i18n="blindcontroller.label.tempBlindPos"></span></label>
        <input type="number" id="node-input-tempBlindPos">
    </div>
    <div class="form-row">
        <label for="node-input-cloudThreshold"><i class="fa fa-cloud"></i> <span data-i18n="blindcontroller.label.cloudThreshold"></span></label>
        <input type="number" id="node-input-cloudThreshold">
    </div>
    <div class="form-row">
        <label for="node-input-cloudBlindPos"><i class="fa fa-angle-down"></i> <span data-i18n="blindcontroller.label.cloudBlindPos"></span></label>
        <input type="number" id="node-input-cloudBlindPos">
    </div>
    <hr>
    <!-- #region End ######################################################################## -->
    <div class="form-row time-topic">
        <label for="node-input-topic"><i class="fa fa-tasks"></i> <span data-i18n="blind-control.label.topic"></span></label>
        <input type="text" id="node-input-topic">
    </div>
    <div class="form-row">
        <label for="node-input-name"><i class="icon-tag"></i> <span data-i18n="blind-control.label.name"></span></label>
        <input type="text" id="node-input-name" data-i18n="[placeholder]blind-control.placeholder.name">
    </div>
    <div class="form-tips">
        <span data-i18n="blind-control.tips.sunPosControl"></span>&nbsp;
    </div>
</script>
<style>
    hr {
        width: 100%
    }
    .block-indent1 {
        float: left;
        min-height: 1px;
        margin-left: 10px;
        width: 100%
    }
    .block-indent2 {
        float: left;
        min-height: 1px;
        margin-left: 20px;
        width: 100%
    }
    .block-noindent .row-full-width {
        width : calc(100% - 110px);
    }
    .block-indent1 .row-full-width {
        width : calc(100% - 120px);
    }
    .block-indent2 .row-full-width {
        width : calc(100% - 130px);
    }
    .block-noindent .ui-spinner {
        width : calc(100% - 245px);
    }
    .block-indent1 .ui-spinner {
        width : calc(100% - 255px);
    }
    .block-indent2 .ui-spinner {
        width : calc(100% - 265px);
    }
    .node-input-multiplier {
        width: 125px;
        margin-left: 5px;
    }
</style>

<script type="text/x-red" data-help-name="blind-control">
    <h3>About</h3>
    <p>Gets the position of the sun</p>

    <h3>Inputs</h3>

    The message is only for trigger the calculation. If limits are defined the input message will send to the output associated to the limit.

 <h3>Outputs</h3>
     <ol class="node-ports">
         <li>first output
             <dl class="message-properties">
                 <dt>payload <span class="property-type">object</span></dt>
                 <dd>gives an object with the following described below</dd>
             </dl>
         </li>
         <li>second and following outputs
                <dl class="message-properties">
                    <dt>payload </dt>
                    <dd>same as the incomming message, which will send to this output.</dd>
                    <dt>posChanged <span class="property-type">boolean</span></dt>
                    <dd>is true if in the previous calculation no message was send to this output, because the azimuth outside the limit.</dd>
                </dl>
            </li>
     </ol>
     <h3>payload output properties</h3>
     <dl class="message-properties">
            <dt>azimuth <span class="property-type">number</span></dt>
            <dd> the azimuth of the sun position relative to the given coordinates.</dd>

            <dt>altitude <span class="property-type">number</span></dt>
            <dd> the altitude (elevation) of the sun position relative to the given coordinates.</dd>

            <dt>times <span class="property-type">object</span></dt>
            <dd>
                the sun times as object
                <dt>times.sunrise <span class="property-type">Date</span></dt>
                <dd>sunrise (top edge of the sun appears on the horizon)</dd>
                <dt>msg.payload.times.astronomicalDawn <span class="property-type">Date</span></dt><dd>night ends (morning astronomical twilight starts)</dd>
                <dt>msg.payload.times.amateurDawn <span class="property-type">Date</span></dt><dd>amateur astronomical dawn (sun at 12° before sunrise)</dd>
                <dt>msg.payload.times.nauticalDawn <span class="property-type">Date</span></dt><dd>nautical dawn (morning nautical twilight starts)</dd>
                <dt>msg.payload.times.blueHourDawnStart <span class="property-type">Date</span></dt><dd>blue Hour start</dd>
                <dt>msg.payload.times.civilDawn <span class="property-type">Date</span></dt><dd>dawn (morning nautical twilight ends, morning civil twilight starts)</dd>
                <dt>msg.payload.times.blueHourDawnEnd <span class="property-type">Date</span></dt><dd>blue Hour end</dd>
                <dt>msg.payload.times.sunrise <span class="property-type">Date</span></dt><dd>sunrise (top edge of the sun appears on the horizon)</dd>
                <dt>msg.payload.times.sunriseEnd <span class="property-type">Date</span></dt><dd>sunrise ends (bottom edge of the sun touches the horizon)</dd>
                <dt>msg.payload.times.goldenHourEnd <span class="property-type">Date</span></dt><dd>morning golden hour (soft light, best time for photography) ends</dd>
                <dt>msg.payload.times.solarNoon <span class="property-type">Date</span></dt><dd>solar noon (sun is in the highest position)</dd>
                <dt>msg.payload.times.goldenHourStart <span class="property-type">Date</span></dt><dd>evening golden hour starts</dd>
                <dt>msg.payload.times.sunsetStart <span class="property-type">Date</span></dt><dd>sunset starts (bottom edge of the sun touches the horizon)</dd>
                <dt>msg.payload.times.sunset <span class="property-type">Date</span></dt><dd>sunset (sun disappears below the horizon, evening civil twilight starts)</dd>
                <dt>msg.payload.times.blueHourDuskStart <span class="property-type">Date</span></dt><dd>blue Hour start</dd>
                <dt>msg.payload.times.civilDusk <span class="property-type">Date</span></dt><dd>dusk (evening nautical twilight starts)</dd>
                <dt>msg.payload.times.blueHourDuskEnd <span class="property-type">Date</span></dt><dd>blue hour end</dd>
                <dt>msg.payload.times.nauticalDusk <span class="property-type">Date</span></dt><dd>nautical dusk end (evening astronomical twilight starts)</dd>
                <dt>msg.payload.times.amateurDusk <span class="property-type">Date</span></dt><dd>amateur astronomical dusk (sun at 12° after sunrise)</dd>
                <dt>msg.payload.times.astronomicalDusk <span class="property-type">Date</span></dt><dd>night starts (dark enough for astronomical observations)</dd>
                <dt>msg.payload.times.nadir <span class="property-type">Date</span></dt><dd>nadir (darkest moment of the night, sun is in the lowest position)</dd>
            </dd>
            <dt>pos <span class="property-type">array of boolean</span></dt>
            <dd> array with a boolean of every defined limit of the azimuth, which is <b>true</b> if the azimuth is inside the limit.</dd>
            <dt>posChanged <span class="property-type">boolean</span></dt>
            <dd> boolean which is true if any of the defined limit of the azimuth has changed to the last calculation.</dd>
            <dt>startTime <span class="property-type">boolean</span></dt>
            <dd> if a start time is defined the start timestamp (inclusive of offset)..</dd>
            <dt>endTime <span class="property-type">boolean</span></dt>
            <dd> if a end time is defined the end timestamp (inclusive of offset).</dd>
            <dt>sunInSky <span class="property-type">boolean</span></dt>
            <dd> if a start and an end time is defined a boolean value indicating whether it is currently considered daylight hours.</dd>
        </dl>
        Example of the first output
        <pre>
{
    "lastUpdate": "2018-11-11T11:11:11.111Z",
    "latitude": "18.473782",
    "longitude": "-34.357051",
    "angleType": "deg",
    "azimuth": 117.72942647370792,
    "altitude": 20.984193272523992,
    "times": {
        "solarNoon":"2018-12-10T10:59:14.814Z",
        "nadir":"2018-12-10T22:59:14.814Z",
        "sunrise":"2018-12-10T06:58:55.584Z",
        "sunset":"2018-12-10T14:59:34.044Z",
        "sunriseEnd":"2018-12-10T07:03:12.232Z",
        "sunsetStart":"2018-12-10T14:55:17.395Z",
        "blueHourDawnEnd":"2018-12-10T06:34:22.885Z",
        "blueHourDuskStart":"2018-12-10T15:24:06.743Z",
        "civilDawn":"2018-12-10T06:19:31.249Z",
        "civilDusk":"2018-12-10T15:38:58.379Z",
        "blueHourDawnStart":"2018-12-10T06:05:03.443Z",
        "blueHourDuskEnd":"2018-12-10T15:53:26.185Z",
        "nauticalDawn":"2018-12-10T05:37:04.859Z",
        "nauticalDusk":"2018-12-10T16:21:24.768Z",
        "amateurDawn":"2018-12-10T05:16:44.832Z",
        "amateurDusk":"2018-12-10T16:41:44.795Z",
        "astronomicalDawn":"2018-12-10T04:56:49.931Z",
        "astronomicalDusk":"2018-12-10T17:01:39.696Z",
        "goldenHourEnd":"2018-12-10T07:58:28.541Z",
        "goldenHourStart":"2018-12-10T14:00:01.086Z",
        "dawn":"2018-12-10T06:19:31.249Z",
        "dusk":"2018-12-10T15:38:58.379Z",
        "nightEnd":"2018-12-10T04:56:49.931Z",
        "night":"2018-12-10T17:01:39.696Z",
        "nightStart":"2018-12-10T17:01:39.696Z",
        "goldenHour":"2018-12-10T14:00:01.086Z"
    },
    "pos": [],
    "posChanged": false
}</pre>
     <h3>Tips</h3>
     <p>For home automation it can be useful to define the lower and higher position for example of the sun for the west side of a house. If this is done, the associated output of this limits, can be used to control the blinds.</p>
    <h3>References</h3>
    <ul>
        <li><a href="https://flows.nodered.org/node/node-red-contrib-sun-position">Node-Red</a> - the Node-Red Node overview</li>
        <li><a href="https://github.com/HM-RedMatic/node-red-contrib-sun-position">GitHub</a> - the nodes github repository</li>
        <li><a href="https://flows.nodered.org/node/node-red-contrib-sun-position">NPM</a> - the nodes npm node description</li>
    </ul>
    With friendly support by <b>agag</b>.
</script>

<!-- Finally, the node type is registered along with all of its properties   -->
<!-- The example below shows a small subset of the properties that can be set-->
<script type="text/javascript">
    function clipValueLength(v) {
        if (v.length > 15) {
            return v.substring(0, 15) + '...';
        }

        return v;
    }

    function prop2name(key) {
        const result = RED.utils.parseContextKey(key);
        return result.key;
    }

    function getValueLabel(t, v) {
        if (t === 'str') {
            return '"' + clipValueLength(v) + '"';
        }

        if (t === 'msg') {
            return t + '.' + clipValueLength(v);
        }

        if (t === 'flow' || t === 'global') {
            return t + '.' + clipValueLength(prop2name(v));
        }

        return clipValueLength(v);
    }

    RED.nodes.registerType('blind-control', {
        category: 'time and astro',
        color: '#FFCC66',
        icon: 'blind.png', // saved in  icons/myicon.png - myicon.png
        inputs: 1, // set the number of inputs - only 0 or 1
        outputs: 2, // 1. Object, 2. nur zahl der Öffnung der Jalousie
        defaults: {
            name: {
                value: '',
                required: false
            },
            topic: {
                value: '',
                required: false
            },
            positionConfig: {
                value: '',
                type: 'position-config',
                required: true
            },
            // #region window settings
            windowTop: {
                value: '',
                required: true,
                validate: RED.validators.number()
            },
            windowBottom: {
                value: '',
                required: true,
                validate: RED.validators.number()
            },
            windowAngle: {
                value: '',
                required: true,
                validate: function (v) {
                    const n = Number(v);
                    return ((n >= 0) && (n <= 360));
                }
            },
            windowAngleOffsetStart: {
                value: '',
                validate: function (v) {
                    const n = Number(v);
                    return ((n >= 0) && (n <= 90));
                }
            },
            windowAngleOffsetEnd: {
                value: '',
                validate: function (v) {
                    const n = Number(v);
                    return ((n >= 0) && (n <= 90));
                }
            },
            // #endregion window settings
            // #region blind settings
            blindIncrement: {
                value: 1,
                required: true,
                validate: function (v) {
                    const n = parseFloat(v);
                    return (n < this.blindOpenPos) && (n > this.blindClosedPos);
                }
            },
            blindOpenPos: {
                value: 100,
                required: true,
                validate: function (v) {
                    const n = parseFloat(v);
                    return (n > this.blindClosedPos) && (Number.isInteger(n / this.blindIncrement));
                }
            },
            blindClosedPos: {
                value: 0,
                required: true,
                validate: function (v) {
                    const n = parseFloat(v);
                    return (n < this.blindOpenPos) && (Number.isInteger(n / this.blindIncrement));
                }
            },
            blindNightPos: {
                value: '',
                validate: function (v) {
                    const n = parseFloat(v);
                    return (v==='') ||
                        ((n <= this.blindOpenPos) &&
                         (n >= this.blindClosedPos) &&
                         (Number.isInteger(n / this.blindIncrement)));
                }
            },
            blindPosOverwriteExpire: {
                value: '',
                validate: function (v) {
                    const n = parseFloat(v);
                    return (v === '') || (n >= 10000);
                }
            },
            blindPosOverwriteExpireMultiplier: {
                value: 60000,
                required: true,
                validate: RED.validators.number()
            },
            // #endregion blind settings
            // #region time settings
            startTime: {
                value: '',
                required: true,
                validate: RED.validators.typedInput('startTimeType')
            },
            startTimeType: {
                value: 'entered'
            },
            startOffset: {
                value: 0,
                validate: (v) => {
                    return (
                        (typeof v === 'undefined') ||
                        (typeof this.startOffsetType === 'undefined') ||
                        RED.validators.typedInput('startOffsetType')(v)
                    );
                }
            },
            startOffsetType: {
                value: 'none'
            },
            startOffsetMultiplier: {
                value: 60000,
                required: true,
                validate: RED.validators.number()
            },
            endTime: {
                value: '',
                required: true,
                validate: RED.validators.typedInput('endTimeType')
            },
            endTimeType: {
                value: 'entered'
            },
            endOffset: {
                value: 0,
                validate: (v) => {
                    return (
                        (typeof v === 'undefined') ||
                        (typeof this.endOffsetType === 'undefined') ||
                        RED.validators.typedInput('endOffsetType')(v)
                    );
                }
            },
            endOffsetType: {
                value: 'none'
            },
            endOffsetMultiplier: {
                value: 60000,
                required: true,
                validate: RED.validators.number()
            },
            propertyStart: {
                value: '',
                required: false,
                validate: RED.validators.typedInput('propertyStartType')
            },
            propertyStartType: {
                value: 'none'
            },
            startTimeAlt: {
                value: '',
                required: false,
                validate: (v) => {
                    return RED.validators.typedInput('startTimeAltType')(v) || ($(
                        '#node-input-propertyStart').typedInput('type') === 'none');
                }
            },
            startTimeAltType: {
                value: 'none'
            },
            startOffsetAlt: {
                value: 0,
                validate: (v) => {
                    return (
                        (typeof v === 'undefined') ||
                        (typeof this.startOffsetAltType === 'undefined') ||
                        RED.validators.typedInput('startOffsetAltType')(v) ||
                        ($('#node-input-propertyStart').typedInput('type') === 'none') ||
                        ($('#node-input-startTimeAlt').typedInput('type') === 'none')
                    );
                }
            },
            startOffsetAltType: {
                value: 'none'
            },
            startOffsetAltMultiplier: {
                value: 60000,
                required: true,
                validate: (v) => {
                    return RED.validators.number()(v) ||
                        ($('#node-input-propertyStart').typedInput('type') === 'none') ||
                        ($('#node-input-startTimeAlt').typedInput('type') === 'none');
                }
            },
            propertyEnd: {
                value: '',
                required: false,
                validate: RED.validators.typedInput('propertyEndType')
            },
            propertyEndType: {
                value: 'none'
            },
            endTimeAlt: {
                value: '',
                required: false,
                validate: (v) => {
                    return RED.validators.typedInput('endTimeAltType')(v) || ($('#node-input-propertyEnd').typedInput(
                        'type') === 'none');
                }
            },
            endTimeAltType: {
                value: 'none'
            },
            endOffsetAlt: {
                value: 0,
                validate: (v) => {
                    return (
                        (typeof v === 'undefined') ||
                        (typeof this.startOffsetAltType === 'undefined') ||
                        RED.validators.typedInput('startOffsetAltType')(v) ||
                        ($('#node-input-propertyEnd').typedInput('type') === 'none') ||
                        ($('#node-input-endTimeAlt').typedInput('type') === 'none')
                    );
                }
            },
            endOffsetAltType: {
                value: 'none'
            },
            endOffsetAltMultiplier: {
                value: 60000,
                required: true,
                validate: (v) => {
                    return RED.validators.number()(v) ||
                        ($('#node-input-propertyEnd').typedInput('type') === 'none') ||
                        ($('#node-input-endTimeAlt').typedInput('type') === 'none');
                }
            },
            tsCompare: {
                value: '0'
            },
            // #endregion time settings
            // #region sun settings
            sunControlActive: {
                value: true,
                required: true,
                validate: function(v) {
                    return (v === true || v === false);
                }
            },
            sunFloorLength: {
                value: 0,
                validate: RED.validators.number()
            },
            sunMinAltitude: {
                value: '',
                required: false,
                validate: function (v) {
                    const n = parseFloat(v);
                    return (v === '' || ((n >= 0) && (n <= 90)));
                }
            },
            notVisiblePos: {
                value: '',
                validate: function (v) {
                    const n = parseFloat(v);
                    return (v === '') ||
                        ((n <= this.blindOpenPos) &&
                            (n >= this.blindClosedPos) &&
                            (Number.isInteger(n / this.blindIncrement)));
                }
            },
            // #endregion sun settings
            // #region weather settings
            tempThreshold: { value: '' },
            tempBlindPos: {
                value: '',
                validate: function (v) {
                    const n = parseFloat(v);
                    return (v === '') ||
                            ((n < this.blindOpenPos) &&
                            (n > this.blindClosedPos) &&
                            (Number.isInteger(n / this.blindIncrement)));
                }
            },
            cloudThreshold: { value: '' },
            cloudBlindPos: {
                value: '',
                validate: function (v) {
                    const n = parseFloat(v);
                    return (v === '') ||
                        ((n < this.blindOpenPos) &&
                            (n > this.blindClosedPos) &&
                            (Number.isInteger(n / this.blindIncrement)));
                }
            }
            // #endregion weather settings
        },
        outputLabels(index) {
            if (index === 0) {
                return ((this.topic) ? this.topic + ':' : '') + 'blind-control';
            }

            const rule = this.rules[index - 1];
            if (rule) {
                return getValueLabel(rule.valueLowType, rule.valueLow) + ' & ' + getValueLabel(rule.valueHighType,
                    rule.valueHigh);
            }
        },
        label() {
            if (this.name) {
                return this.name;
            }
            const result = 'blind-control';
            if (this.topic && (this.topic.length + result.length <= 32)) {
                return this.topic + ':' + result;
            }
            return result;
        },
        labelStyle() {
            return this.name ? 'node_label_italic' : '';
        },
        paletteLabel: 'blind-control',
        oneditprepare() {
            const node = this;
            const setup = function(node) {
                /* global getTypes appendOptions setupTInput */
                const types = getTypes();
                // #region initialize
                function multilpierUpdate(mp, name) {
                    const field = $('#node-input-' + name);
                    appendOptions(node, 'blind-control', field, 'multiplier', (id) => (id > 0));
                    if (mp === null || typeof mp === 'undefined' || isNaN(mp) || mp === '' || mp === 0) {
                        mp = 60000;
                    }
                    field.val(mp);
                    return mp;
                }

                // #region start
                const startTypeField = setupTInput(node, {
                    typeProp: 'startType',
                    valueProp: 'start',
                    width: 'calc(100% - 110px)',
                    defaultType: types.Undefined.value,
                    defaultValue: '',
                    types: [types.Undefined, types.TimeEntered, types.TimeSun, types.TimeMoon, 'flow', 'global', 'env'],
                    onChange: (_type, _value) => {
                        if ($('#node-input-start').typedInput('type') === types.Undefined.value) {
                            $('.blind-control-row-startOffset').hide();
                        } else {
                            $('.blind-control-row-startOffset').show();
                        }

                        $('#node-input-property').change();
                    }
                });

                node.startOffsetMultiplier = multilpierUpdate(node.startOffsetMultiplier, 'startOffsetMultiplier');
                setupTInput(node, {
                    typeProp: 'startOffsetType',
                    valueProp: 'startOffset',
                    width: 'calc(100% - 255px)',
                    defaultType: (node.startOffset === 0 || node.startOffset === '') ? types.Undefined.value : 'num',
                    defaultValue: 0,
                    types: [types.Undefined, 'num', 'msg', 'flow', 'global', 'env'],
                    onChange: (_type, _value) => {
                        const type = $('#node-input-startOffset').typedInput('type');
                        if (type === types.Undefined.value) {
                            $('#node-input-startOffsetMultiplier').prop('disabled', true);
                        } else {
                            $('#node-input-startOffsetMultiplier').prop('disabled', false);
                        }
                    }
                }).change();
                startTypeField.change();
                // #endregion start

                // #region end
                const endTypeField = setupTInput(node, {
                    typeProp: 'endType',
                    valueProp: 'end',
                    width: 'calc(100% - 110px)',
                    defaultType: types.Undefined.value,
                    defaultValue: '',
                    types: [types.Undefined, types.TimeEntered, types.TimeSun, types.TimeMoon, 'flow', 'global', 'env'],
                    onChange: (_type, _value) => {
                        if ($('#node-input-end').typedInput('type') === types.Undefined.value) {
                            $('.blind-control-row-endOffset').hide();
                        } else {
                            $('.blind-control-row-endOffset').show();
                        }

                        $('#node-input-property').change();
                    }
                });

                node.endOffsetMultiplier = multilpierUpdate(node.endOffsetMultiplier, 'endOffsetMultiplier');
                setupTInput(node, {
                    typeProp: 'endOffsetType',
                    valueProp: 'endOffset',
                    width: 'calc(100% - 255px)',
                    defaultType: (node.endOffset === 0 || node.endOffset === '') ? types.Undefined.value : 'num',
                    defaultValue: 0,
                    types: [types.Undefined, 'num', 'msg', 'flow', 'global', 'env'],
                    onChange: (_type, _value) => {
                        const type = $('#node-input-endOffset').typedInput('type');
                        if (type === types.Undefined.value) {
                            $('#node-input-endOffsetMultiplier').prop('disabled', true);
                        } else {
                            $('#node-input-endOffsetMultiplier').prop('disabled', false);
                        }
                    }
                }).change();
                endTypeField.change();
                // #endregion end
                const outputCount = $('#node-input-outputs').val('{}');

                const btwnLabel = node._('blind-control.label.between');
                const andLabel = node._('blind-control.label.and');

                function resizeRule(rule) {
                    const newWidth = rule.width();
                    const btwnField1 = rule.find('.node-input-rule-btwn-value');
                    const btwnField2 = rule.find('.node-input-rule-btwn-value2');
                    const editwidth = (newWidth / 2);
                    btwnField1.typedInput('width', (editwidth - 70));
                    btwnField2.typedInput('width', (editwidth - 70));
                }

                $('#node-input-rule-container').css('min-height', '100px').css('min-width', '200px').editableList({
                    addItem(container, i, opt) {
                        container.css({
                            overflow: 'hidden',
                            whiteSpace: 'nowrap'
                        });
                        if (!opt.hasOwnProperty('r')) {
                            opt.r = {};
                        }

                        if (!opt.hasOwnProperty('i')) {
                            opt._i = Math.floor((0x99999 - 0x10000) * Math.random()).toString();
                        }

                        const rule = opt.r;
                        const row = $('<div/>').appendTo(container);
                        /* const row3 = $('<div/>', {
                            style: 'padding-top: 5px;'
                        }).appendTo(container); */

                        /* validate: function (v) {
                            var n = Number(v);
                            return ((n >= 0) && (n <= 360));
                        } */

                        $('<span/>', {
                            class: 'node-input-rule-btwn-label'
                        }).text(' ' + btwnLabel + ' ').appendTo(row);
                        const btwnValueField = $('<input/>', {
                            class: 'node-input-rule-btwn-value',
                            type: 'text',
                            style: 'margin-left: 5px;'
                        }).appendTo(row).typedInput({
                            default: 'num',
                            types: ['msg', 'flow', 'global', 'num', 'env']
                        });
                        $('<span/>', {
                            class: 'node-input-rule-btwn-label'
                        }).text(' ' + andLabel + ' ').appendTo(row);
                        const btwnValue2Field = $('<input/>', {
                            class: 'node-input-rule-btwn-value2',
                            type: 'text',
                            style: 'margin-left:2px;'
                        }).appendTo(row).typedInput({
                            default: 'num',
                            types: ['msg', 'flow', 'global', 'num', 'env']
                        });

                        const finalspan = $('<span/>', {
                            style: 'float: right;margin-top: 6px;'
                        }).appendTo(row);
                        finalspan.append(' &#8594; <span class="node-input-rule-index">' + (i + 2) +
                    '</span> ');

                        resizeRule(container);
                        btwnValueField.typedInput('value', rule.valueLow);
                        btwnValueField.typedInput('type', rule.valueLowType || 'num');
                        btwnValue2Field.typedInput('value', rule.valueHigh);
                        btwnValue2Field.typedInput('type', rule.valueHighType || 'num');

                        // {"0":0,"1":-1,"2":-1,"3":-1}
                        // {"0":0}
                        const currentOutputs = JSON.parse(outputCount.val() || '{}');
                        currentOutputs[opt.hasOwnProperty('i') ? opt.i : opt._i] = i;
                        currentOutputs.m = i + 1;
                        // console.log(currentOutputs);
                        outputCount.val(JSON.stringify(currentOutputs));
                    },
                    removeItem(opt) {
                        const currentOutputs = JSON.parse(outputCount.val() || '{"-1":-1}');
                        if (opt.hasOwnProperty('i')) {
                            currentOutputs[opt.i] = -1;
                        } else {
                            delete currentOutputs[opt._i];
                        }

                        const rules = $('#node-input-rule-container').editableList('items');
                        rules.each(function (i) {
                            $(this).find('.node-input-rule-index').html(i + 2);
                            const data = $(this).data('data');
                            currentOutputs[data.hasOwnProperty('i') ? data.i : data._i] = i;
                        });
                        currentOutputs.m = rules.length;
                        // console.log(currentOutputs);
                        // console.log(rules);
                        outputCount.val(JSON.stringify(currentOutputs));
                    },
                    resizeItem: resizeRule,
                    sortItems(rules) {
                        const currentOutputs = JSON.parse(outputCount.val() || '{}');
                        rules = $('#node-input-rule-container').editableList('items');
                        rules.each(function (i) {
                            $(this).find('.node-input-rule-index').html(i + 2);
                            const data = $(this).data('data');
                            currentOutputs[data.hasOwnProperty('i') ? data.i : data._i] = i;
                        });
                        currentOutputs.m = rules.length;
                        // console.log(currentOutputs);
                        // console.log(rules);
                        outputCount.val(JSON.stringify(currentOutputs));
                    },
                    sortable: true,
                    removable: true
                });

                for (let i = 0; i < node.rules.length; i++) {
                    const rule = node.rules[i];
                    $('#node-input-rule-container').editableList('addItem', {
                        r: rule,
                        i,
                        l: node.rules.length
                    });
                }
            }; // setup
            $.getScript('sun-position/js/htmlglobal.js')
                .done((_data, _textStatus, _jqxhr) => {
                    try {
                        setup(node);
                    } catch (err) {
                        console.log("failed to setup editor"); // eslint-disable-line
                        console.log(err); // eslint-disable-line
                        console.log(err.stack); // eslint-disable-line
                    }
                })
                .fail((jqxhr, settings, exception) => {
                    console.log("failed to load htmlglobal.js"); // eslint-disable-line
                    console.log(exception); // eslint-disable-line
                    console.log(exception.stack); // eslint-disable-line
                });
        },
        oneditsave() {
            const rules = $('#node-input-rule-container').editableList('items');
            const node = this;

            node.rules = [];
            rules.each(function ( _i ) {
                // const ruleData = $(this).data('data');
                const rule = $(this);
                const r = {};
                r.valueLow = rule.find('.node-input-rule-btwn-value').typedInput('value');
                r.valueLowType = rule.find('.node-input-rule-btwn-value').typedInput('type');
                r.valueHigh = rule.find('.node-input-rule-btwn-value2').typedInput('value');
                r.valueHighType = rule.find('.node-input-rule-btwn-value2').typedInput('type');
                node.rules.push(r);
            });
            node.propertyType = $('#node-input-property').typedInput('type');
            // var outputCount = $("#node-input-outputs").val(); //"{}"

            const currentOutputs = JSON.parse($('#node-input-outputs').val() || '{"m":0}');
            currentOutputs.m = rules.length;
            // console.log(currentOutputs);
            // console.log(rules);
            $('#node-input-outputs').val(JSON.stringify(currentOutputs));
        // outputCount.val(JSON.stringify(currentOutputs));
        },
        oneditresize(size) {
            const rows = $('#dialog-form>div:not(.node-input-rule-container-row)');
            let height = size.height;
            for (let i = 0; i < rows.size(); i++) {
                height -= $(rows[i]).outerHeight(true);
            }

            const editorRow = $('#dialog-form>div.node-input-rule-container-row');
            height -= (parseInt(editorRow.css('marginTop')) + parseInt(editorRow.css('marginBottom')));
            height -= 50;
            $('#node-input-rule-container').editableList('height', height);
        }
    });</script>