<script type="text/x-red" data-template-name="time-inject">
    <div class="form-row">
        <label for="node-input-positionConfig"><i class="fa fa-globe"></i> <span data-i18n="time-inject.label.position"></span></label>
        <input type="text" id="node-input-positionConfig">
    </div>
    <hr>
    <div class="form-row">
        <label for="node-input-startTime"><i class="fa fa-clock-o"></i> <span data-i18n="time-inject.label.startTime"></span></label>
        <input type="text" id="node-input-startTime" style="width: 70%"/>
        <input type="hidden" id="node-input-startTimeType">
    </div>
    <div class="form-row time-start-row time-start-offset hidden">
        <label for="node-input-startOffset"><i class="fa fa-arrows-h"></i> <span data-i18n="time-inject.label.startOffset"></span></label>
        <input id="node-input-startOffset"" class="wt-offset-time" data-i18n="[placeholder]time-inject.placeholder.startOffset">
    </div>
    <div class="form-row time-start-row time-start-payload hidden">
        <label for="node-input-payloadStart"><i class="fa fa-envelope"></i> <span data-i18n="time-inject.label.payloadStart"></span></label>
        <input type="text" id="node-input-payloadStart" style="width:70%">
        <input type="hidden" id="node-input-payloadStartType">
    </div>
    <div class="form-row time-start-row time-start-topic hidden">
        <label for="node-input-topicStart"><i class="fa fa-tasks"></i> <span data-i18n="time-inject.label.topicStart"></span></label>
        <input type="text" id="node-input-topicStart">
    </div>
    <hr>
    <div class="form-row">
        <label for="node-input-endTime"><i class="fa fa-clock-o"></i> <span data-i18n="time-inject.label.endTime"></span></label>
        <input type="text" id="node-input-endTime" style="width: 70%"/>
        <input type="hidden" id="node-input-endTimeType">
    </div>
    <div class="form-row time-end-row time-end-offset hidden">
        <label for="node-input-endOffset"><i class="fa fa-arrows-h"></i> <span data-i18n="time-inject.label.endOffset"></span></label>
        <input id="node-input-endOffset" class="wt-offset-time" data-i18n="[placeholder]time-inject.placeholder.endOffset">
    </div>
    <div class="form-row time-end-row time-end-payload hidden">
        <label for="node-input-payloadEnd"><i class="fa fa-envelope"></i> <span data-i18n="time-inject.label.payloadEnd"></span></label>
        <input type="text" id="node-input-payloadEnd" style="width:70%">
        <input type="hidden" id="node-input-payloadEndType">
    </div>
    <div class="form-row time-end-row time-end-topic hidden">
        <label for="node-input-topicStart"><i class="fa fa-tasks"></i> <span data-i18n="time-inject.label.topicStart"></span></label>
        <input type="text" id="node-input-topicStart">
    </div>
    <hr>
    <div class="form-row">
        <label for="node-input-name"><i class="icon-tag"></i> <span data-i18n="time-inject.label.name"></span></label>
        <input type="text" id="node-input-name" data-i18n="[placeholder]time-inject.placeholder.name">
    </div>
  </script>

<script type="text/x-red" data-help-name="time-inject">
    <p>Uses the suncalc module to generate an output at sunrise and sunset based on a specified location.</p>
      <p>Several choices of definition of sunrise and sunset are available, see the <i><a href = "https://github.com/mourner/suncalc" target="_new">suncalc</a></i> module for details.</p>
      <p>The first output emits a <code>msg.payload</code> of <i>1</i> or <i>0</i> every minute depending if in between selected times or not.
      The second output emits only on the transition between night to day (<i>-> 1</i>) or day to night (<i>-> 0</i>).</p>
      <p>Also sets <code>msg.topic</code> to <i>sun</i> and <code>msg.moon</code> to the fraction of the moon between 0 and 1.</p>
  </script>

<script type="text/javascript">
    RED.nodes.registerType('time-inject', {
        category: 'input',
        color: "#a6bbcf",
        defaults: {
            name: {
                value: "",
                required: false
            },
            positionConfig: {
                value: "",
                type: "position-config",
                required: true
            },
            startTime: {
                value: "",
                required: false,
                validate: RED.validators.typedInput("startTimeType")
            },
            startTimeType: {
                value: "none"
            },
            startOffset: {
                value: 0,
                required: true,
                validate: function (v) {
                    return RED.validators.number()(v) ||
                        ($("#node-input-startTime").typedInput('type') === 'none');
                }
            },
            payloadStart: {
                value: "",
                validate: function (v) {
                    return RED.validators.typedInput("payloadStartType")(v) ||
                        ($("#node-input-startTime").typedInput('type') === 'none');
                }
            },
            payloadStartType: {
                value: "date"
            },
            topicStart: {
                value: ""
            },
            endTime: {
                value: "",
                required: false,
                validate: RED.validators.typedInput("endTimeType")
            },
            endTimeType: {
                value: "none"
            },
            endOffset: {
                value: 0,
                required: true,
                validate: function (v) {
                    return RED.validators.number()(v) ||
                        ($("#node-input-endTime").typedInput('type') === 'none');
                }
            },
            payloadEnd: {
                value: "",
                validate: function (v) {
                    return RED.validators.typedInput("payloadEndType")(v) ||
                        ($("#node-input-endTime").typedInput('type') === 'none');
                }
            },
            payloadEndType: {
                value: "date"
            },
            topicEnd: {
                value: ""
            }
        },
        icon: "injectSun.png",
        inputs: 0,
        outputs: 1,
        outputLabels: ["once per minute", "only on change"],
        label: function () {
            if (this.name) {
                return this.name;
            }
            if ((this.startTimeType === 'none' || this.startTimeType === '') &&
                (this.endTimeType === 'none' || this.endTimeType === '')) {
                return 'inject';
            }
            if (this.name) {
                return this.name;
            }
            var result = "";
            const getId = (type, value) => {
                if (type === "string" ||
                    type === "str" ||
                    type === "num" ||
                    type === "bool") {
                    return value;
                } else if (type === 'jsonata') {
                    return "json expr.";
                } else if (type === 'json') {
                    return "json";
                } else if (type === 'bin') {
                    return "binary";
                } else if (type === 'date') {
                    return "timestamp";
                } else if (type === 'flow' || type === 'global') {
                    return type + '.' + value;
                } else if (type == 'pdmTime') {
                    return 'moon ' + value;
                }
                return value;
            }
            if (this.startTimeType !== 'none' && this.startTimeType !== '') {
                let part1 = getId(this.startTimeType, this.startTime);
                if (part1.length > 24) {
                    result += part1 + '=...';
                } else {
                    result += part1 + '=' + getId(this.payloadStartType, this.payloadStart);
                }
            }
            if (this.endTimeType !== 'none' && this.endTimeType !== '') {
                let part1 = getId(this.endTimeType, this.endTime);
                let part2 = getId(this.payloadEndType, this.payloadEnd);
                if (result.length > 0) {
                    result += ' / ';
                }

                if (result.length > 24) {
                    result += '...';
                } else if (result.length + part1.length > 24) {
                    result += part1 + '=...';
                } else if (result.length > 0) {
                    result += part1 + '=...';
                } else {
                    result += part1 + '=' + part2;
                }
            }
            if (this.topic && (this.topic.length + result.length <= 32)) {
                return this.topic + ":" + result;
            }
            return result;
        },
        labelStyle: function () {
            return this.name ? "node_label_italic" : "";
        },
        paletteLabel: 'time inject',
        align: 'left',
        oneditprepare: function () {
            if (this.payloadStartType == null) {
                if (this.payloadStart == "") {
                    this.payloadStartType = "date";
                } else {
                    this.payloadStartType = "str";
                }
            } else if (this.payloadStartType === 'string' || this.payloadStartType === 'none') {
                this.payloadStartType = "str";
            }
            if (this.payloadEndType == null) {
                if (this.payloadEnd == "") {
                    this.payloadEndType = "date";
                } else {
                    this.payloadEndType = "str";
                }
            } else if (this.payloadEndType === 'string' || this.payloadEndType === 'none') {
                this.payloadEndType = "str";
            }
            let typeTimeNone = {
                value: "none",
                label: "not used",
                icon: "icons/node-red-contrib-sun-position/inputTypeNone.png",
                hasValue: false
            };
            let typeTime = {
                value: "entered",
                label: "timestamp",
                icon: "icons/node-red-contrib-sun-position/inputTypeTime.png",
                hasValue: true,
                validate: /^(0[0-9]|[0-9]|1[0-9]|2[0-3])(?::([0-5][0-9]|[0-9]))?(?::([0-5][0-9]|[0-9]))?\s*(pm?)?$/
            };
            let typeTimeSun = {
                value: "pdsTime",
                label: "sun ",
                icon: "icons/node-red-contrib-sun-position/inputTypeSun.png",
                options: ['solarNoon', 'nadir', 'sunrise', 'sunset', 'sunriseEnd',
                    'sunsetStart', 'dawn', 'dusk', 'nauticalDawn', 'nauticalDusk',
                    'nightEnd', 'night', 'goldenHourEnd', 'goldenHour'
                ]
            };
            let typeTimeMoon = {
                value: "pdmTime",
                label: "moon ",
                icon: "icons/node-red-contrib-sun-position/inputTypeMoon.png",
                options: ['rise', 'set']
            };
            $("#node-input-startTimeType").val(this.startTimeType);
            $("#node-input-startTime").typedInput({
                default: this.startTimeType || 'none',
                typeField: $("#node-input-startTimeType"),
                types: [typeTimeNone, typeTime, typeTimeSun, typeTimeMoon, 'flow', 'global']
            });
            $("#node-input-startTime").on('change', function (type, value) {
                if ($("#node-input-startTime").typedInput('type') === 'none') {
                    $(".time-start-row").hide();
                } else {
                    $(".time-start-row").show();
                }
            });
            $("#node-input-payloadStartType").val(this.payloadStartType);
            $("#node-input-payloadStart").typedInput({
                default: this.payloadStartType || 'date',
                typeField: $("#node-input-payloadStartType"),
                types: ['flow', 'global', 'str', 'num', 'bool', 'json', 'bin', 'date', 'env',
                    'jsonata'
                ]
            });
            $("#node-input-endTimeType").val(this.endTimeType);
            $("#node-input-endTime").typedInput({
                default: this.endTimeType || 'none',
                typeField: $("#node-input-endTimeType"),
                types: [typeTimeNone, typeTime, typeTimeSun, typeTimeMoon, 'flow', 'global']
            });
            $("#node-input-endTime").on('change', function (type, value) {
                if ($("#node-input-endTime").typedInput('type') === 'none') {
                    $(".time-end-row").hide();
                } else {
                    $(".time-end-row").show();
                }
            });
            $("#node-input-payloadEndType").val(this.payloadEndType);
            $("#node-input-payloadEnd").typedInput({
                default: this.endTimeType || 'date',
                typeField: $("#node-input-payloadEndType"),
                types: ['flow', 'global', 'str', 'num', 'bool', 'json', 'bin', 'date', 'env',
                    'jsonata'
                ]
            });
            $(".wt-offset-time").spinner({
                max: 1439,
                min: -1439
            });
            $("#node-input-startTime").change();
            $("#node-input-endTime").change();
        },
        oneditsave: function () {
            this.startTimeType = $("#node-input-startTime").typedInput('type');
            this.payloadStartType = $("#node-input-payloadStart").typedInput('type');
            this.endTimeType = $("#node-input-endTime").typedInput('type');
            this.payloadEndType = $("#node-input-payloadEnd").typedInput('type');
        },
        button: {
            enabled: function () {
                return !this.changed
            },
            onclick: function () {
                if (this.changed) {
                    return RED.notify(RED._("notification.warning", {
                        message: RED._("notification.warnings.undeployedChanges")
                    }), "warning");
                }
                var payload = this.payloadStart;
                if ((this.payloadStartType === 'flow') ||
                    (this.payloadStartType === 'global')) {
                    var key = RED.utils.parseContextKey(payload);
                    payload = this.payloadStartType + "." + key.key;
                }
                var label = (this.name || payload);
                if (label.length > 30) {
                    label = label.substring(0, 50) + "...";
                }
                label = label.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                if (this.payloadStartType === "date") {
                    label = this._("inject.timestamp");
                }
                if (this.payloadStartType === "none") {
                    label = this._("inject.blank");
                }
                var node = this;
                $.ajax({
                    url: "inject/" + this.id,
                    type: "POST",
                    success: function (resp) {
                        RED.notify(node._("inject.success", {
                            label: label
                        }), "success");
                    },
                    error: function (jqXHR, textStatus, errorThrown) {
                        if (jqXHR.status == 404) {
                            RED.notify(node._("common.notification.error", {
                                message: node._(
                                    "common.notification.errors.not-deployed")
                            }), "error");
                        } else if (jqXHR.status == 500) {
                            RED.notify(node._("common.notification.error", {
                                message: node._("inject.errors.failed")
                            }), "error");
                        } else if (jqXHR.status == 0) {
                            RED.notify(node._("common.notification.error", {
                                message: node._(
                                    "common.notification.errors.no-response")
                            }), "error");
                        } else {
                            RED.notify(node._("common.notification.error", {
                                message: node._(
                                    "common.notification.errors.unexpected", {
                                        status: jqXHR.status,
                                        message: textStatus
                                    })
                            }), "error");
                        }
                    }
                });
            }
        }
    });
</script>