<script type="text/x-red" data-template-name="time-calc"> <div class="form-row">
    <label for="node-input-positionConfig"><i class="fa fa-globe"></i> <span data-i18n="time-calc.label.position"></span></label>
    <input type="text" id="node-input-positionConfig">
    <input type="hidden" id="node-input-outputs"/>
  </div>
  <hr>
  <div class="form-row time-operand1">
      <label for="node-input-operand1"><i class="fa fa-plus-square-o"></i> <span data-i18n="time-calc.label.operand1"></span></label>
      <input type="text" id="node-input-operand1" style="width:70%">
      <input type="hidden" id="node-input-operand1Type">
  </div>
  <div class="form-row time-calc-row-operand1Format hidden">
      <label for="node-input-operand1Formatsel"><i class="fa fa-calendar"></i> <span data-i18n="time-calc.label.operand1Format"></span></label>
      <select style="width:70%" id="node-input-operand1Formatsel">
      <input type="text" id="node-input-operand1Format" style="width:50%; margin-left: 5px;">
  </div>
  <div class="form-row time-calc-row-operand1Offset hidden">
      <label for="node-input-operand1Offset"><i class="fa fa-arrows-h"></i> <span data-i18n="time-calc.label.operand1Offset"></span></label>
      <input id="node-input-operand1Offset" class="wt-offset-time" data-i18n="[placeholder]time-calc.placeholder.offset">
      <select style="width:100px" id="node-input-operand1OffsetMultiplier">
      </select>
  </div>
  <hr>
  <div>
    <label for="node-input-rule-container-row"><i class="fa fa-calculator"></i> <span data-i18n="time-calc.label.operatorContainer"></span></label>
    <div class="form-row node-input-rule-container-row">
      <ol id="node-input-rule-container"></ol>
    </div>
  </div>
  <div class="form-row">
      <select id="node-input-checkall" style="width:100%; margin-right:5px;">
          <option value="false" data-i18n="time-calc.label.stopfirst"></option>
          <option value="true" data-i18n="time-calc.label.checkall"></option>
      </select>
  </div>
  <hr class="time-calc-result">
  <div class="form-row time-result1">
      <label for="node-input-result1"><i class="fa fa-plus-square-o"></i> <span data-i18n="time-calc.label.result1"></span></label>
      <input type="text" id="node-input-result1" style="width:70%">
      <input type="hidden" id="node-input-result1Type">
  </div>
  <div class="form-row time-result1Value hidden">
      <label for="node-input-result1Value"><i class="fa fa-envelope-o"></i> <span data-i18n="time-calc.label.result1Value"></span></label>
      <input type="text" id="node-input-result1Value" style="width:70%">
      <input type="hidden" id="node-input-result1ValueType">
  </div>
  <div class="form-row time-calc-row-result1Format hidden">
      <label for="node-input-result1FormatSel"><i class="fa fa-calendar"></i> <span data-i18n="time-calc.label.result1Format"></span></label>
      <select style="width:70%" id="node-input-result1FormatSel">
      </select>
      <input type="text" id="node-input-result1Format" style="width:50%; margin-left: 5px;">
  </div>
  <div class="form-row time-calc-row-result1Offset hidden">
      <label for="node-input-result1Offset"><i class="fa fa-arrows-h"></i> <span data-i18n="time-calc.label.result1Offset"></span></label>
      <input id="node-input-result1Offset" class="wt-offset-time" data-i18n="[placeholder]time-calc.placeholder.offset">
      <select style="width:100px" id="node-input-result1OffsetMultiplier">
      </select>
  </div>
  <hr>
  <div class="form-row">
      <label for="node-input-name"><i class="icon-tag"></i> <span data-i18n="time-calc.label.name"></span></label>
      <input type="text" id="node-input-name" data-i18n="[placeholder]time-calc.placeholder.name">
  </div>
</script>
<style>
    .node-input-rule-operator {
        width: 60px;
        margin-left: 5px;
        text-align: center;
    }
    .node-input-rule-operand {
        margin-left: 5px;
    }
    .node-input-rule-operandFormatIp {
        width:0px;
        margin-left: 5px;
        text-align: left;
    }
    .node-input-rule-operandFormatSel {
        width:70px;
        margin-left: 5px;
        text-align: left;
    };
    .node-input-rule-offset {
        margin-left: 5px;
    }
    .node-input-rule-multiplier {
        width:100px;
        margin-left: 5px;
    }
    .node-input-rule-property {
        margin-left: 5px;
        width:70px
    }
    .time-calc-times {
        width: 90px;
    }
    #time-calc-time {
        width: 75px;
        margin-left: 8px;
        margin-bottom: 8px;
    }
    .time-calc-count {
        width: 40px !important;
    }
    .multiselect {
        width: 60px;
        display: inline-block;
    }
    .selectBox {
        position: relative;
    }
    .selectBox select {
        width: 100%;
        font-weight: bold;
    }
    .overSelect {
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
    }
    #option-checkboxes {
        display: none;
        border: 1px #dadada solid;
        background: #ffffff;
        min-width: 150px;
        /* width: 200px; */
        position: absolute;
        z-index: 90000;
    }
    #option-checkboxes label {
        display: block;
        width: auto;
        text-align: left;
        margin-right:15px;
        margin-left:5px;
    }
    #option-checkboxes .header {
        background:#cccccc;
        margin-left:5px;
        margin-right:5px;
    }
    #option-checkboxes input {
        display: block;
        width: auto;
        margin-right:5px;
        margin-left:5px;
        float:left;
        /* clear: both; */
    }
    #option-checkboxes label:hover {
        background-color: #1e90ff;
    }
</style>
<script type="text/x-red" data-help-name="time-calc"> <p>Injects a message into a flow either manually or at timestamps which can also depending on the sunset, sunrise, or moon set and rise. The message
  payload can be a variety of types, including strings, JavaScript objects, the current time or the cuttent sun or moon position.</p>
  <h3>Outputs</h3>
  <dl class="message-properties">
      <dt>payload<span class="property-type">various</span></dt>
      <dd>The configured payload of the message.</dd>
      <dt class="optional">topic <span class="property-type">string</span></dt>
      <dd>An optional property that can be configured in the node.</dd>
      <dt class="optional">time <span class="property-type">time</span></dt>
      <dd>An optional property that can be configured when the inject node should emit a message on that timestamp.</dd>
      <dt class="optional">offset <span class="property-type">number</span></dt>
      <dd>An optional property which is only available if an time is choosen. The offset can be a positive or negative and defines a time offset to the choosen time.</dd>
      <dt class="optional">day select <span class="property-type">number</span></dt>
      <dd>An optional property which is only available if an time is choosen. There can be defined on which days a msg should be emited.</dd>
  </dl>
  <h3>Details</h3>
  <p>The time-calc node can initiate a flow with a specific payload value.
  The default payload is a timestamp of the current time in millisecs since January 1st, 1970.</p>
  <p>The node also supports injecting strings, numbers, booleans, JavaScript objects, or flow/global context values.</p>
  <p>By default, the node is triggered manually by clicking on its button within the editor. It can also be set to
  inject at specified time stamp in a daily interval which can be set directly or by using the suncalc module to generate an output at various sunrise, sunset, moonrise or moonset times based on a specified location.</p>
  <p><b>Note</b>: The next timestamp will be calculated if a timestamp is reached, settings are changed or the inject node is manual triggered. For a given timestamp (or an alternate timestamp) through a flow or global context a recalculation time could be defined. Then planned emit time then is recalculated every end of this interval. Changes to the contexts then only lead to a change of the planned emit time if a recalculation is done!</p>
  <p><b>Note</b>: To include a newline in a string you must use a Function node to create the payload.</p>

  <h3>Sun times:</h3>
  <p>
    <table>
        <thead>
        <tr>
        <th>Time</th>
        <th>Description</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><code>astronomicalDawn</code></td>
        <td>night ends (morning astronomical twilight starts)</td>
        </tr>
        <tr>
        <td><code>amateurDawn</code></td>
        <td>amateur astronomical dawn (sun at 12Â° before sunrise)</td>
        </tr>
        <tr>
        <td><code>nauticalDawn</code></td>
        <td>nautical dawn (morning nautical twilight starts)</td>
        </tr>
        <tr>
        <td><code>blueHourDawnStart</code></td>
        <td>blue Hour start (time for special photography photos starts)</td>
        </tr>
        <tr>
        <td><code>civilDawn</code></td>
        <td>dawn (morning nautical twilight ends, morning civil twilight starts)</td>
        </tr>
        <tr>
        <td><code>blueHourDawnEnd</code></td>
        <td>blue Hour end (time for special photography photos end)</td>
        </tr>
        <tr>
        <td><code>sunrise</code></td>
        <td>sunrise (top edge of the sun appears on the horizon)</td>
        </tr>
        <tr>
        <td><code>sunriseEnd</code></td>
        <td>sunrise ends (bottom edge of the sun touches the horizon)</td>
        </tr>
        <tr>
        <td><code>goldenHourEnd</code></td>
        <td>morning golden hour (soft light, best time for photography) ends</td>
        </tr>
        <tr>
        <td><code>solarNoon</code></td>
        <td>solar noon (sun is in the highest position)</td>
        </tr>
        <tr>
        <td><code>goldenHourStart</code></td>
        <td>evening golden hour starts</td>
        </tr>
        <tr>
        <td><code>sunsetStart</code></td>
        <td>sunset starts (bottom edge of the sun touches the horizon)</td>
        </tr>
        <tr>
        <td><code>sunset</code></td>
        <td>sunset (sun disappears below the horizon, evening civil twilight starts)</td>
        </tr>
        <tr>
        <td><code>blueHourDuskStart</code></td>
        <td>blue Hour start (time for special photography photos starts)</td>
        </tr>
        <tr>
        <td><code>civilDusk</code></td>
        <td>dusk (evening nautical twilight starts)</td>
        </tr>
        <tr>
        <td><code>blueHourDuskEnd</code></td>
        <td>blue Hour end (time for special photography photos end)</td>
        </tr>
        <tr>
        <td><code>nauticalDusk</code></td>
        <td>nautical dusk end (evening astronomical twilight starts)</td>
        </tr>
        <tr>
        <td><code>amateurDusk</code></td>
        <td>amateur astronomical dusk (sun at 12Â° after sunrise)</td>
        </tr>
        <tr>
        <td><code>astronomicalDusk</code></td>
        <td>night starts (dark enough for astronomical observations)</td>
        </tr>
        <tr>
        <td><code>nadir</code></td>
        <td>nadir (darkest moment of the night, sun is in the lowest position)</td>
        </tr>
        </tbody>
        </table>
  </p>
  <p>It can also be configured to inject once each time the flows are started.</p>
  <h3>References</h3>
  <ul>
      <li><a href="https://flows.nodered.org/node/node-red-contrib-sun-position">Node-Red</a> - the Node-Red Node overview</li>
      <li><a href="https://github.com/HM-RedMatic/node-red-contrib-sun-position">GitHub</a> - the nodes github repository</li>
      <li><a href="https://flows.nodered.org/node/node-red-contrib-sun-position">NPM</a> - the nodes npm node description</li>
  </ul>
  With friendly support by <b>agag</b>.
</script>
<script type="text/javascript">
    function clipValueLength(v, l) {
        if (v.length > l) {
            return v.substring(0, l - 3) + "...";
        }
        return v;
    }

    function getValueLabel(t, v, l) {
        l = l || 15;
        if (t === "string" || t === "str") {
            if (v == '') { return v; }
            return '"' + clipValueLength(v, l) + '"';
        } else if (t === "num" || t === "bool") {
            if (v == '') { return v; }
            return '' + v;
        } else if (t === "msg") {
            return t + "." + clipValueLength(v, l);
        } else if (t === "flow" || t === "global") {
            var result = RED.utils.parseContextKey(v);
            return t + "." + clipValueLength(result.key, l);
        } else if (t == "operand1") {
            return "input data";
        } else if (t == "pdsCalcData") {
            return "{sun position}";
        } else if (t == "pdmCalcData") {
            return "{moon position}";
        } else if (t == "pdsTime") {
            let res = v.replace("astronomical", "astro-").replace("nautical", "naut-").replace("civil", '').replace("amateur", "amat-").replace("blueHour", "blHr-").replace("goldenHour", "goHr-");
            return clipValueLength(res, l);
        } else if (t == "pdmTime") {
            return "moon" + v;
        }
        return clipValueLength(v, l);
    }
    RED.nodes.registerType("time-calc", {
        category: "time and astro",
        color: "#FDF0C2",
        icon: "time-calc-black.png",
        inputs: 1,
        outputs: 1,
        defaults: {
            outputs: {
                value: 1
            },
            name: {
                value: '',
                required: false
            },
            positionConfig: {
                value: '',
                type: "position-config",
                required: true
            },
            //#region operand1
            operand1: {
                value: "payload",
                validate: RED.validators.typedInput("operand1Type")
            },
            operand1Type: {
                value: "msg"
            },
            operand1Format: {
                value: 0,
                required: true,
                validate: function (v) {
                    return RED.validators.number()(v) || typeof v === "undefined";
                }
            },
            operand1Offset: {
                value: 0,
                required: true,
                validate: RED.validators.number()
            },
            operand1OffsetMultiplier: {
                value: 60,
                required: true,
                validate: RED.validators.number()
            },
            //#endregion operand1
            //#region rules
            rules: {
                value: {}
            },
            checkall: {
                value: "true",
                required: true
            },
            //#endregion rules
            //#region result1
            result1: {
                value: "payload",
                validate: RED.validators.typedInput("result1Type")
            },
            result1Type: {
                value: "msg"
            },
            result1Value: {
                value: '',
                validate: function (v) {
                    return (RED.validators.typedInput("result1ValueType")(v) || $("#node-input-result1").typedInput("type") === "none" || this.result1Type === undefined);
                }
            },
            result1ValueType: {
                value: "operand1"
            },
            result1Format: {
                value: 0,
                required: false,
                validate: function (v) {
                    return (RED.validators.number()(v) || $("#node-input-result1").typedInput("type") === "none" || this.result1Type === undefined);
                }
            },
            result1Offset: {
                value: 0,
                required: false,
                validate: function (v) {
                    return (RED.validators.number()(v) || $("#node-input-result1").typedInput("type") === "none" || this.result1Type === undefined);
                }
            },
            result1OffsetMultiplier: {
                value: 60,
                required: false,
                validate: RED.validators.number()
            }
            //#endregion result1
        },
        outputLabels: function () {
            var label = '';
            if (this.rules.length) {
                var rule = this.rules[index];
                if (rule) {
                    label = rule.operatorText + getValueLabel(rule.operandType, rule.operandValue);
                    if (data.propertyType != "none") {
                        label += ' only if ' + getValueLabel(rule.propertyType, rule.propertyValue) + ' is true';
                    }
                    return label;
                }
                if (checkall) {
                    return "always";
                }
                return "otherwise";
                //return ["msg if comparision is true", "msg if comparision is false"];
            } else {
                return "input msg after evaluation";
            }
        },
        label: function () {
            if (this.name) {
                return this.name;
            }
            let label = '';
            if (!this.rules || this.rules.length <= 1) {
                let op1 = getValueLabel(this.operand1Type, this.operand1);
                return op1;
            } else if (this.rules && this.rules.length == 1) {
                let op1 = getValueLabel(this.operand1Type, this.operand1);
                let op2 = getValueLabel(this.rules[0].operandType, this.rules[0].operandValue);
                return op1 + this.rules[0].operatorText + op2;
            } else if (this.rules && this.rules.length == 1) {
                let op1 = getValueLabel(this.operand1Type, this.operand1);
                let op2 = getValueLabel(this.rules[0].operandType, this.rules[0].operandValue);
                return op1 + this.rules[0].operatorText + op2;
            }
            return this._("time-calc.label.time-calc");
        },
        labelStyle: function () {
            return this.name ? "node_label_italic" : '';
        },
        paletteLabel: "time calc",
        align: "left",
        oneditprepare: function () {
            node = this;
            //#region definition
            const SelectFields = {
                operatorsGroups: [
                    { id: "cmp", label: "compate Timestamp" },
                ],
                operators: [
                    { id: 1, group: "cmp", label: "==", "text": "equal" },
                    { id: 2, group: "cmp", label: "!=", "text": "unequal" },
                    { id: 3, group: "cmp", label: ">", "text": "greater" },
                    { id: 4, group: "cmp", label: ">=", "text": "greater or equal" },
                    { id: 5, group: "cmp", label: "<", "text": "lesser" },
                    { id: 6, group: "cmp", label: "<=", "text": "lesser or equal" }
                ], operatorTypesGroups: [
                    { id: "std", label: "include into compare" },
                    { id: "spec", label: "special" }
                ], operatorTypes: [
                    { id: 11, group: "std", label: "Milliseconds" },
                    { id: 12, group: "std", label: "Seconds" },
                    { id: 13, group: "std", label: "Minutes" },
                    { id: 14, group: "std", label: "Hours" },
                    { id: 15, group: "std", label: "Day of Month" },
                    { id: 16, group: "std", label: "Month" },
                    { id: 17, group: "std", label: "Year" },
                    { id: 18, group: "spec", label: "Day of Week" },
                ], operatorTypesShort: [
                    { selection: /(^\*$|^(11,)?12,13,14,15,16(,17)?(,18)?$)/, label: 'DT' },
                    { selection: /^(11,)?12,13,14$/, label: 'T' },
                    { selection: /^15,16(,17)?(,18)?$/, label: 'D' }
                ], outputFormatsGroups: [
                    { id: "number", label: "Number" },
                    { id: "string", label: "Text (string)" },
                    { id: "time", label: "time (number) since emit" },
                    { id: "dayofweek", label: "day of week" },
                    { id: "other", label: "Other" }
                ], outputFormats: [
                    { id: 0, group: "number", name: "UNIX", label: "milliseconds UNIX timestamp" },
                    { id: 10, group: "number", name: "YYYYMMDDHHMMSS", label: "YYYYMMDDHHMMSS" },
                    { id: 11, group: "number", name: "YYYYMMDD_HHMMSS", label: "YYYYMMDD.HHMMSS" },
                    { id: 1, group: "string", "name": "ECMA262", label: "ECMA-262", add: "standard JSON Date representation" },
                    { id: 2, group: "string", name: "local", label: "local date and time" },
                    { id: 14, group: "string", name: "localLong", label: "local date and time enh." },
                    { id: 3, group: "string", name: "localTime", label: "local time" },
                    { id: 13, group: "string", name: "localTimeLong", label: "ocal time enh." },
                    { id: 12, group: "string", name: "localDate", label: "local date" },
                    { id: 15, group: "string", name: "localDateLong", label: "local date long" },
                    { id: 4, group: "string", name: "UTC", label: "UTC date and time" },
                    { id: 5, group: "string", name: "ISO", label: "ISO date and time" },
                    { id: 6, group: "time", name: "ms", label: "milliseconds" },
                    { id: 7, group: "time", name: "sec", label: "seconds" },
                    { id: 8, group: "time", name: "min", label: "minutes" },
                    { id: 9, group: "time", name: "hour", label: "hours" },
                    { id: 16, group: "dayofweek", name: "ISO", label: "Day Name, e.g. Monday, 22.12." },
                    { id: 17, group: "dayofweek", name: "ISO", label: "Day in relative, e.g. Today, 22.12." },
                    { id: -1, group: "other", name: "object", label: "as object" },
                    { id: 99, group: "other", name: "free definition", label: "Other" }
                ], parseFormatsGroups: [
                    { id: "number", label: "Number" },
                    { id: "string", label: "Text (string)" },
                    { id: "other", label: "Other" }
                ], parseFormats: [
                    { id: 0, group: "number", label: "milliseconds UNIX timestamp", add: "xxx" },
                    { id: 1, group: "string", label: "ECMA-262", add: "standard JSON Date representation" },
                    { id: 2, group: "string", label: "various - try different Formats", add: "will try different formats" },
                    { id: 3, group: "number", label: "YYYYMMDDHHMMSS", add: "xxx" },
                    { id: 4, group: "number", label: "YYYYMMDD.HHMMSS", add: "xxx" },
                    { id: 99, group: "other", label: "free definition", add: "xxx" }
                ], multiplierGroups: [
                    { id: "std", label: "Standard" },
                    { id: "other", label: "Special" },
                ], multiplier: [
                    { id: 1, group: "std", label: "seconds" },
                    { id: 60, group: "std", label: "minutes" },
                    { id: 3600, group: "std", label: "hours" },
                    { id: 86400, group: "std", label: "days" },
                    { id: 604800, group: "other", label: "weeks" },
                    { id: -1, group: "other", label: "month" },
                    { id: -2, group: "other", label: "year" }
                ]
            }
            const typeUnlimited = {
                value: "none",
                label: "no limitation",
                //icon: "icons/node-red-contrib-sun-position/inputTypeNone.png",
                hasValue: false
            };
            const typeUndefined = {
                value: "none",
                label: "not used",
                //icon: "icons/node-red-contrib-sun-position/inputTypeNone.png",
                hasValue: false
            };
            const typeTimeEntered = {
                value: "entered",
                label: "time (current day)",
                icon: "icons/node-red-contrib-sun-position/inputTypeTime.png",
                hasValue: true,
                validate: /^(0[0-9]|[0-9]|1[0-9]|2[0-3])(?::([0-5][0-9]|[0-9]))?(?::([0-5][0-9]|[0-9]))?\s*(pm?)?$/
            };
            const typeDateEntered = {
                value: "dateEntered",
                label: "date",
                icon: "icons/node-red-contrib-sun-position/inputTypeDate.png",
                hasValue: true
            };
            const typeTimePedefined = {
                value: "predefined",
                label: "time (current day)",
                options: ["midnight (current day)", "noon (current day)", "last this month (0:00)"]
            };
            const typeTimeSun = {
                value: "pdsTime",
                label: "sun time ",
                icon: "icons/node-red-contrib-sun-position/inputTypeSunClock.png",
                options: ["astronomicalDawn", "amateurDawn", "nauticalDawn", "blueHourDawnStart", "civilDawn", "blueHourDawnEnd", "sunrise", "sunriseEnd", "goldenHourEnd", "solarNoon", "goldenHourStart", "sunsetStart", "sunset", "blueHourDuskStart", "civilDusk", "blueHourDuskEnd", "amateurDusk", "astronomicalDusk", "nadir"]
            };
            const typeTimeMoon = {
                value: "pdmTime",
                label: "moon time ",
                icon: "icons/node-red-contrib-sun-position/inputTypeMoonClock.png",
                options: ["rise", "set"]
            };
            const typeSunCalc = {
                value: "pdsCalcData",
                label: "sun caclucaltion",
                icon: "icons/node-red-contrib-sun-position/inputTypeSun.png",
                hasValue: false
            };
            const typeMoonCalc = {
                value: "pdmCalcData",
                label: "moon caclucaltion",
                icon: "icons/node-red-contrib-sun-position/inputTypeMoon.png",
                hasValue: false
            };
            var dateParseFormat = [{ label: 'yy   Year (2 digits)', value: 'yy' }, { label: 'yyyy Year (4 digits)', value: 'yyyy' }, { label: 'M    Month (1 digit)', value: 'M' }, { label: 'MM   Month (2 digits)', value: 'MM' }, { label: 'MMM  Month (name or abbr.)', value: 'MMM' }, { label: 'NNN  Month (abbr.)', value: 'NNN' }, { label: 'd    Day of Month (1 digit)', value: 'd' }, { label: 'dd   Day of Month (2 digits)', value: 'dd' }, { label: 'E    Day of Week (abbr)', value: 'E' }, { label: 'EE   Day of Week (name)', value: 'EE' }, { label: 'h    Hour (1 digit 1-12)', value: 'h' }, { label: 'hh   Hour (2 digits 1-12)', value: 'hh' }, { label: 'H    Hour (1 digit 0-23)', value: 'H' }, { label: 'HH   Hour (2 digits 0-23)', value: 'HH' }, { label: 'K    Hour (1 digit 0-11)', value: 'K' }, { label: 'KK   Hour (2 digits 0-11)', value: 'KK' }, { label: 'k    Hour (1 digit 1-24)', value: 'k' }, { label: 'kk   Hour (2 digits 1-24)', value: 'kk' }, { label: 'm    Minute (1 digit)', value: 'm' }, { label: 'mm   Minute (2 digits)', value: 'mm' }, { label: 's    Second (1 digit)', value: 's' }, { label: 'ss   Second (2 digits)', value: 'ss' }, { label: 'll   Milliseconds (2 digits)', value: 'll' }, { label: 'lll  Milliseconds (3 digits)', value: 'lll' }, { label: 't    AM/PM (1 digit)', value: 't' }, { label: 'tt   AM/PM (2 digits)', value: 'tt' }];
            var dateOutFormat = [{ label: 'yyyy Year (4 digits)', value: 'yyyy' }, { label: 'yy   Year (2 digits)', value: 'yy' }, { label: 'M    Month (1 digit)', value: 'M' }, { label: 'MM   Month (2 digits)', value: 'MM' }, { label: 'MMM  Month (abbr.)', value: 'MMM' }, { label: 'NNN  Month (name)', value: 'NNN' }, { label: 'd    Day of Month (1 digit)', value: 'd' }, { label: 'dd   Day of Month (2 digits)', value: 'dd' }, { label: 'E    Day of Week (abbr)', value: 'E' }, { label: 'EE   Day of Week (name)', value: 'EE' }, { label: 'h    Hour (1-12)', value: 'h' }, { label: 'hh   Hour (2 digits 01-12)', value: 'hh' }, { label: 'H    Hour (0-23)', value: 'H' }, { label: 'HH   Hour (2 digits 00-23)', value: 'HH' }, { label: 'K    Hour (0-11)', value: 'K' }, { label: 'KK   Hour (2 digits 00-11)', value: 'KK' }, { label: 'k    Hour (1-24)', value: 'k' }, { label: 'kk   Hour (2 digits 01-24)', value: 'kk' }, { label: 'm    Minute (0-59)', value: 'm' }, { label: 'mm   Minute (2 digits 00-59)', value: 'mm' }, { label: 's    Second (0-59)', value: 's' }, { label: 'ss   Second (2 digits 00-59)', value: 'ss' }, { label: 'l    Milliseconds (0-999)', value: 'l' }, { label: 'll   Milliseconds (2 digits 00-99)', value: 'll' }, { label: 'lll  Milliseconds (3 digits 000-999)', value: 'lll' }, { label: 't    AM/PM (1 digit - Lowercase)', value: 't' }, { label: 'tt   AM/PM (2 digits - Lowercase)', value: 'tt' }, { label: 'T    AM/PM (1 digit - Uppercase)', value: 'T' }, { label: 'TT   AM/PM (2 digits - Uppercase)', value: 'TT' }, { label: 'Z    timezone (abbr.)', value: 'Z' }, { label: 'o    timezone offset (abbr.)', value: 'o' }, { label: "S    date's ordinal suffix (st, nd, rd, or th)", value: 'S' }, { label: 'x    Day difference', value: 'x' }, { label: 'xx   Day difference (name)', value: 'xx' }];
            $.fn.getCursorPosition = function () {
                var input = this.get(0);
                if (!input) return; // No (input) element found
                if ('selectionStart' in input) {
                    // Standard-compliant browsers
                    return input.selectionStart;
                } else if (document.selection) {
                    // IE
                    input.focus();
                    var sel = document.selection.createRange();
                    var selLen = document.selection.createRange().text.length;
                    sel.moveStart('character', -input.value.length);
                    return sel.text.length - selLen;
                }
            }
            function getMultiselectText(val, length, types) {
                for (let index = 0; index < types.length; index++) {
                    if (types[index].selection.test(val)) {
                        return types[index].label;
                    }
                }
                if (length > 0) {
                    return length;
                }
                return 'NA';
            }
            function setMultiselect(value, field, types) {
                if (value == "*" || typeof value === "undefined") {
                    field.find("#option-checkboxes input[type=checkbox]").prop("checked", true);
                    field.find('.multiselect-option').text(getMultiselectText("*", 99, types));
                } else {
                    field.find("#option-checkboxes input[type=checkbox]").removeAttr("checked");
                    let elm = value.split(",");
                    elm.forEach(function (v) {
                        field.find("#option-checkboxes [value=" + v + "]").prop("checked", true);
                    });
                    field.find('.multiselect-option').text(getMultiselectText(value, elm.length, types));
                }
            }
            function multiselect(parent, elementName, id) {
                let types = SelectFields[elementName + 'Short'];

                let getSelection = function getCBText(parent) {
                    let value = parent.find("#option-checkboxes input[type=checkbox]:checked")
                    let elements = value
                        .map(function (_, el) {
                            return $(el).val();
                        })
                        .get();
                    parent.find('.multiselect-option').text(getMultiselectText(elements.join(","), elements.length, types));
                }

                let multiselect = $('<div/>', { class: 'multiselect', id: id }).appendTo(parent);

                let selectbox = $('<div/>', {
                    class: 'selectBox',
                    html: $('<select/>', {
                        id: 'multiselect-select',
                        class: 'multiselect-select',
                        html: $('<option></option>', {
                            id: 'multiselect-option',
                            class: 'multiselect-option',
                        }).text('x')
                    })
                }).appendTo(multiselect);
                $('<div/>', { class: 'overSelect' }).appendTo(selectbox);

                let list = $('<div/>', {
                    id: 'option-checkboxes',
                    class: 'option-checkboxes'
                }).appendTo(multiselect)
                list.attr("expanded", "false");

                let groups = SelectFields[elementName + 'Groups'];
                let groupLength = groups.length;
                let elements = SelectFields[elementName];
                let elementsLength = elements.length;

                for (let gIndex = 0; gIndex < groupLength; gIndex++) {
                    list.append($("<label></label>", {
                        class: "header",
                        html: node._("time-calc." + elementName + 'Groups.' + gIndex)
                    }));
                    for (let eIndex = 0; eIndex < elementsLength; eIndex++) {
                        if (groups[gIndex].id === elements[eIndex].group) {
                            let lbl = list.append($("<label></label>", {
                                for: id + '-' + elements[eIndex].id,
                                html: [$("<input>", {
                                    class: id + '-checkbox',
                                    type: 'checkbox',
                                    value: elements[eIndex].id,
                                    id: id + '-' + elements[eIndex].id
                                }).on("change", function (event) {
                                    getSelection(multiselect);
                                }), node._("time-calc." + elementName + '.' + eIndex)]
                            }));
                            //elements[eIndex].label
                        }
                    }
                }
                selectbox.on("click", function (event) {
                    let checkboxes = parent.find(".option-checkboxes");
                    let expanded = (checkboxes.attr("expanded") === "true");
                    if (!expanded) {
                        checkboxes.css("display", "block");
                        checkboxes.attr("expanded", "true");
                    } else {
                        checkboxes.css("display", "none");
                        checkboxes.attr("expanded", "false");
                    }
                });

                return multiselect;
            }
            function autocomplete(inputBox, dataList) {
                // don't navigate away from the field on tab when selecting an item
                inputBox.on("keydown", function (event) {
                    if (event.keyCode === $.ui.keyCode.TAB && $(this).autocomplete("instance") && $(this).autocomplete("instance").menu.active) {
                        event.preventDefault();
                    }
                }).autocomplete({
                    minLength: 0,
                    source: function (request, response) {
                        if (inputBox.getCursorPosition() < request.term.length) {
                            return;
                        }
                        // delegate back to autocomplete, but extract the last term
                        var term = request.term.split(/\W+/).pop()
                        var result = dataList.filter(x => x.value.startsWith(term));
                        response(result);
                    },
                    focus: function () {
                        // prevent value inserted on focus
                        return false;
                    },
                    select: function (event, ui) {
                        var terms = this.value.split(/\W+/);
                        // remove the current input
                        terms.pop();
                        // add the selected item
                        terms.push(ui.item.value);
                        // add placeholder to get the comma-and-space at the end
                        terms.push('');
                        this.value = terms.join(" ");
                        return false;
                    }
                });
            }

            function appendOptions(parent, elementName) {
                let groups = SelectFields[elementName + 'Groups'];
                let elements = SelectFields[elementName];
                let groupLength = groups.length;
                let elementsLength = elements.length;
                for (let gIndex = 0; gIndex < groupLength; gIndex++) {
                    let group = $('<optgroup/>', { label: node._("time-calc." + elementName + 'Groups.' + gIndex) }).appendTo(parent);
                    for (let eIndex = 0; eIndex < elementsLength; eIndex++) {
                        if (groups[gIndex].id === elements[eIndex].group) {
                            group.append($("<option></option>").val(elements[eIndex].id).text(node._("time-calc." + elementName + '.' + eIndex)).attr("addText", elements[eIndex].add));
                        }
                    }
                }
            }
            //#endregion definition
            //#region spinner
            $(".wt-offset-time").spinner({ max: 1439, min: -1439 });
            //#endregion spinner
            //#region operand1
            $("#node-input-operand1Type").val(node.operand1Type);
            $("#node-input-operand1").typedInput({
                default: node.operand1Type || "msg",
                typeField: $("#node-input-operand1Type"),
                types: ["msg", "flow", "global", "date", "str", "num", typeTimeSun, typeTimeMoon, "env"]
            });
            $("#node-input-operand1").on("change", function (type, value) {
                let opType = $("#node-input-operand1").typedInput("type");
                if (opType === typeTimeEntered.value || opType === typeTimeSun.value || opType === typeTimeMoon.value || opType === "date") {
                    $(".time-calc-row-operand1Format").hide();
                    $(".time-calc-row-operand1Offset").show();
                } else if (opType === typeDateEntered.value || opType === "msg" || opType === "flow" || opType === "global" || opType === "str" || opType === "num" || opType === "env") {
                    $(".time-calc-row-operand1Format").show();
                    $(".time-calc-row-operand1Offset").show();
                } else {
                    $(".time-calc-row-operand1Format").hide();
                    $(".time-calc-row-operand1Offset").hide();
                }
            });
            let inputFormatSelField = $('#node-input-operand1Formatsel');
            appendOptions(inputFormatSelField, "parseFormats");
            autocomplete($("#node-input-operand1Format"), dateParseFormat);
            inputFormatSelField.on("change", function (type, value) {
                let inputFormatIpField = $("#node-input-operand1Format");
                let inputFormatSelField = $('#node-input-operand1Formatsel');
                if (Number(inputFormatSelField.val()) == 99) {
                    inputFormatIpField.show();
                    $('#node-input-operand1Format').css({ 'width': '40%' });
                    inputFormatSelField.css({ 'width': '30%' });
                    if (!isNaN(inputFormatIpField.val())) {
                        inputFormatIpField.val(node._("time-calc.timeFormat.default"));
                    }
                } else {
                    inputFormatIpField.hide();
                    inputFormatSelField.css({ 'width': '70%' });
                }
            });
            if (isNaN(node.operand1Format)) {
                inputFormatSelField.val(99);
            } else {
                inputFormatSelField.val(Number(node.operand1Format));
            }
            inputFormatSelField.change();
            var inputMultiplierField = $('#node-input-operand1OffsetMultiplier');
            appendOptions(inputMultiplierField, "multiplier");
            inputMultiplierField.val(node.operand1OffsetMultiplier);
            //#endregion operand1
            //#region rule-container
            function resizeRule(rule) {
                var newWidth = rule.width() - 10;
                var operatorField = rule.find(".node-input-rule-operator");
                var operandField = rule.find(".node-input-rule-operand");
                var formatSelField = rule.find(".node-input-rule-operandFormatSel");
                var formatIpField = rule.find(".node-input-rule-operandFormatIp");
                var offsetField = rule.find(".node-input-rule-offset");
                var multipierField = rule.find(".node-input-rule-multipier");
                var propertyField = rule.find(".node-input-rule-property");
                var propertyLblSpanField = rule.find(".node-input-rule-property-span");
                var propertyLblField = rule.find(".node-input-rule-property-lbl");
                var lblWidth = 25;
                //row1
                var operatorWidth = 120;
                operandField.typedInput("width", (newWidth - operatorWidth - lblWidth - 50));
                //row2
                var formatWidth = (newWidth - lblWidth - 18);
                if (Number(formatSelField.val()) == 99) {
                    formatIpField.show();
                    formatWidth = Math.floor(formatWidth / 3);
                    formatSelField.width(formatWidth - 5);
                    formatIpField.width((formatWidth * 2) - 10);
                } else {
                    formatIpField.hide();
                    //formatIpField.width(0);
                    formatSelField.width(formatWidth);
                }
                //row3
                let multiplierWidth = 100;
                multipierField.width(multiplierWidth);
                offsetField.typedInput("width", (newWidth - multiplierWidth - lblWidth - 10));
                //row4
                let lblwidth = propertyLblSpanField.width() + 25;
                propertyField.typedInput("width", (newWidth - lblwidth - 10));
                propertyLblField.width(lblwidth);
            }
            $("#node-input-rule-container").css('min-height', '250px').css('min-width', '300px').editableList({
                addItem: function (containerRow, containerIndex, data) {
                    function addLabel(row, forEl, symb, text) {
                        let lbl = $('<label class="' + forEl + '-lbl"/>').attr("for", forEl).appendTo(row);
                        if (symb) {
                            lbl.append('<i class= "' + symb + '" >');
                        }
                        if (text) {
                            let span = $('<span class="' + forEl + '-span" style="float: right; margin-left: 5px; */">' + text + '</span>');
                            lbl.append(span);
                            lbl.attr("style", 'margin-left: 5px; width:' + 20 + span.width() + 'px;');
                        } else {
                            lbl.attr("style", "margin-left: 5px; width:20px");
                        }
                        return lbl;
                    }
                    containerRow.css({ overflow: 'hidden', whiteSpace: 'nowrap' });
                    var row = $('<div/>').appendTo(containerRow);
                    var row2 = $('<div/>', { style: "padding-top: 5px;" }).appendTo(containerRow);
                    var row3 = $('<div/>', { style: "padding-top: 5px;" }).appendTo(containerRow);
                    var row4 = $('<div/>', { style: "padding-top: 5px;" }).appendTo(containerRow);
                    //row1
                    //operator
                    var operatorField = $('<select/>', {
                        class: "node-input-rule-operator",
                        id: "node-input-rule-operator" + containerIndex
                    }).appendTo(row);
                    appendOptions(operatorField, "operators");
                    var operatorTypeField = multiselect(row, 'operatorTypes', 'node-input-rule-operatorType-' + containerIndex);

                    var operandLabel = addLabel(row, "node-input-rule-operand", "fa fa-clock-o");
                    var operandField = $('<input/>', {
                        class: "node-input-rule-operand",
                        id: "node-input-rule-operand" + containerIndex,
                        type: "text"
                    }).appendTo(row).typedInput({
                        default: "str",
                        types: ["msg", "flow", "global", "date", "str", "num", typeTimeSun, typeTimeMoon, "bin", "env", "jsonata"]
                    });
                    var finalspan = $('<span/>', {
                        style: "float: right; margin-top: 6px;"
                    }).appendTo(row);
                    finalspan.append(' &#8594; <span class="node-input-rule-index">' + (containerIndex + 1) + '</span> ');
                    //row2
                    let operandSelFieldName = "node-input-rule-operandFormatSel";
                    var formatLabel = addLabel(row2, operandSelFieldName, "fa fa-file-code-o");
                    var formatSelField = $('<select/>', {
                        class: operandSelFieldName,
                        id: operandSelFieldName + containerIndex,
                    }).appendTo(row2);
                    appendOptions(formatSelField, "parseFormats");
                    var formatIpField = $('<input/>', {
                        class: "node-input-rule-operandFormatIp",
                        id: "node-input-rule-operandFormatIp" + containerIndex,
                        type: "text"
                    }).appendTo(row2);
                    formatSelField.change(function () {
                        resizeRule(containerRow);
                    });
                    //row3
                    var offsetLabel = addLabel(row3, "node-input-rule-offset", "fa fa-plus");
                    var offsetField = $('<input/>', {
                        class: "node-input-rule-offset",
                        id: "node-input-rule-offset" + containerIndex,
                        type: "text"
                    }).appendTo(row3).typedInput({
                        default: typeUndefined.value,
                        types: [typeUndefined, "num", "msg", "flow", "global"]
                    });
                    var multiplierField = $('<select/>', {
                        class: "node-input-rule-multiplier",
                        id: "node-input-rule-multiplier" + containerIndex
                    }).appendTo(row3);
                    appendOptions(multiplierField, "multiplier");
                    //row4
                    var propertyLabel = addLabel(row4, "node-input-rule-property", "fa fa-puzzle-piece", node._('time-calc.label.onlyif'));
                    var propertyField = $('<input/>', {
                        class: "node-input-rule-property",
                        id: "node-input-rule-property" + containerIndex,
                        type: "text"
                    }).appendTo(row4).typedInput({
                        default: typeUnlimited.value,
                        types: [typeUnlimited, 'msg', 'flow', 'global', 'env']
                    });
                    //changes
                    operandField.change(function () {
                        operandField.show();
                        let opType = operandField.typedInput("type");
                        if (opType === typeTimeEntered.value || opType === typeTimeSun.value || opType === typeTimeMoon.value || opType === "date") {
                            row2.hide(); //format
                            row3.show(); //offset
                            row4.show(); //limit
                        } else if (opType === typeDateEntered.value || opType === "msg" || opType === "flow" || opType === "global" || opType === "str" || opType === "num" || opType === "env") {
                            row2.show(); //format
                            row3.show(); //offset
                            row4.show(); //limit
                        } else {
                            row2.hide(); //format
                            row3.hide(); //offset
                            row4.show(); //limit
                        }
                    });
                    //setting defaultValues
                    //console.log(data);
                    operatorField.val(data.operator || SelectFields.operators[0].id);
                    setMultiselect(data.operatorType, operatorTypeField, SelectFields.operatorTypesShort);
                    operandField.typedInput('type', data.operandType || "str");
                    operandField.typedInput('value', data.operandValue || '');
                    formatIpField.val(data.format || node._("time-calc.timeFormat.default"));
                    formatSelField.val(data.formatSelection || SelectFields.parseFormats[0].id);
                    offsetField.typedInput('type', data.offsetType || typeUndefined.value);
                    offsetField.typedInput('value', data.offsetValue || '');
                    multiplierField.val(data.multiplier || SelectFields.multiplier[0].id);
                    propertyField.typedInput('type', data.propertyType || typeUnlimited.value);
                    propertyField.typedInput('value', data.propertyValue || '');
                    resizeRule(containerRow);
                    autocomplete(formatIpField, dateParseFormat);
                },
                sortItems: function (rules) {
                    var rules = $("#node-input-rule-container").editableList('items');
                    rules.each(function (i) {
                        $(this).find(".node-input-rule-index").html(i + 1);
                    });
                },
                resizeItem: resizeRule,
                sortable: true,
                removable: true
            });
            for (let i = 0; i < node.rules.length; i++) {
                let rule = node.rules[i];
                $("#node-input-rule-container").editableList('addItem', rule);
            }
            //#endregion rule-container
            //#region result1
            $("#node-input-result1Type").val(node.result1Type);
            $("#node-input-result1").typedInput({
                default: node.result1Type || typeUndefined.value,
                typeField: $("#node-input-result1Type"),
                types: [typeUndefined, "msg", "flow", "global"]
            });
            $("#node-input-result1ValueType").val(node.result1ValueType);
            $("#node-input-result1Value").typedInput({
                default: node.result1ValueType || "operand1",
                typeField: $("#node-input-result1ValueType"),
                types: [{ value: "operand1", label: "Input value", hasValue: false }, "date",
                    typeTimeEntered,
                    typeTimeSun,
                    typeTimeMoon, "flow", "global", "str", "num", "bool", "json", "bin", "env", "jsonata",
                    typeSunCalc,
                    typeMoonCalc
                ]
            });
            $("#node-input-result1").on("change", function (type, value) {
                if ($("#node-input-result1").typedInput("type") !== typeUndefined.value) {
                    $(".time-result1Value").show();
                    let plVType = $("#node-input-result1Value").typedInput("type");
                    if (plVType === typeTimeEntered.value || plVType === typeTimeSun.value || plVType === typeTimeMoon.value || plVType === "date") {
                        $(".time-calc-row-result1Format").show();
                        $(".time-calc-row-result1Offset").show();
                    } else if (plVType === "operand1") {
                        $(".time-calc-row-result1Format").show();
                        $(".time-calc-row-result1Offset").hide();
                    } else {
                        $(".time-calc-row-result1Format").hide();
                        $(".time-calc-row-result1Offset").hide();
                    }
                } else {
                    $(".time-result1Value").hide();
                    $(".time-calc-row-result1Format").hide();
                    $(".time-calc-row-result1Offset").hide();
                }
            });
            $("#node-input-result1Value").on("change", function (type, value) {
                $("#node-input-result1").change();
            });
            /********************************************************/
            let resultFormatSelField = $('#node-input-result1FormatSel');
            appendOptions(resultFormatSelField, "outputFormats");
            resultFormatSelField.on("change", function (type, value) {
                let resultFormatIpField = $("#node-input-result1Format");
                let resultFormatSelField = $('#node-input-result1FormatSel');
                if (Number(resultFormatSelField.val()) == 99) {
                    resultFormatIpField.show();
                    resultFormatIpField.css({ 'width': '40%' });
                    resultFormatSelField.css({ 'width': '30%' });
                    if (!isNaN(resultFormatIpField.val())) {
                        resultFormatIpField.val(node._("time-calc.timeFormat.default"));
                    }
                } else {
                    resultFormatIpField.hide();
                    resultFormatSelField.css({ 'width': '70%' });
                }
            });
            if (isNaN(node.result1Format)) {
                resultFormatSelField.val(99);
            } else {
                resultFormatSelField.val(Number(node.result1Format));
            }
            resultFormatSelField.change();
            var resultMultiplierField = $('#node-input-result1OffsetMultiplier');
            appendOptions(resultMultiplierField, "multiplier");
            resultMultiplierField.val(node.result1OffsetMultiplier);
            autocomplete($("#node-input-result1Format"), dateOutFormat);
            //#endregion result1
            $("#node-input-time").change();
            $("#node-input-property").change();
            $("#node-input-payload").change();
            $("#node-input-operand1").change();
            $("#node-input-result1").change();
        },
        oneditsave: function () {
            function getMultiSelStr(value) {
                let elements = value
                    .map(function (_, el) {
                        return $(el).val();
                    })
                    .get();

                if (elements.length == 0) {
                    return '';
                } else {
                    return elements.join(",");
                }
            }
            var node = this;
            node.rules = [];
            var rules = $("#node-input-rule-container").editableList('items');
            rules.each(function (i) {
                var rule = $(this);
                var data = {
                    operator: rule.find(".node-input-rule-operator").val(),
                    operatorType: getMultiSelStr(rule.find("#option-checkboxes input[type=checkbox]:checked")),
                    operatorText: rule.find(".node-input-rule-operator").children(':selected').text(),
                    operandType: rule.find(".node-input-rule-operand").typedInput('type'),
                    operandValue: rule.find(".node-input-rule-operand").typedInput('value'),
                    format: rule.find(".node-input-rule-operandFormatIp").val(),
                    formatSelection: rule.find(".node-input-rule-operandFormatSel").val(),
                    offsetType: rule.find(".node-input-rule-offset").typedInput('type'),
                    offsetValue: rule.find(".node-input-rule-offset").typedInput('value'),
                    multiplier: rule.find(".node-input-rule-multipier").val(),
                    propertyType: rule.find(".node-input-rule-property").typedInput('type'),
                    propertyValue: rule.find(".node-input-rule-property").typedInput('value'),
                };
                node.rules.push(data);
            });
            //console.log(this.rules);
            let outputs = node.rules.length + 1;
            $("#node-input-outputs").val(outputs);
            //console.log(outputs);
            if (Number($('#node-input-operand1Formatsel').val()) != 99) {
                $('#node-input-operand1Format').val($('#node-input-operand1Formatsel').val());
                node.operand1Format = $('#node-input-operand1Formatsel').val();
            }
            if (Number($('#node-input-result1FormatSel').val()) != 99) {
                $('#node-input-result1Format').val($('#node-input-result1FormatSel').val());
                node.result1Format = $('#node-input-result1FormatSel').val();
            }
            node.operand1Type = $("#node-input-operand1").typedInput("type");
            node.result1Type = $("#node-input-result1").typedInput("type");
            node.result1ValueType = $("#node-input-result1Value").typedInput("type");
            node.result2Type = $("#node-input-result2").typedInput("type");
            node.result2ValueType = $("#node-input-result2Value").typedInput("type");
            //console.log($("#node-input-outputs").val());
        },
        oneditresize: function (size) {
            var rows = $("#dialog-form>div:not(.node-input-rule-container-row)");
            var height = size.height;
            for (let i = 0; i < rows.size(); i++) {
                height -= $(rows[i]).outerHeight(true);
            }
            var editorRow = $("#dialog-form>div.node-input-rule-container-row");
            height -= (parseInt(editorRow.css("marginTop")) + parseInt(editorRow.css("marginBottom")));
            $("#node-input-rule-container").editableList('height', height);
        }
    });
</script>